[{
    "id": "0",
    "type": "tool",
    "title": "Toolbox - API Developer Weekly Newsletter",
    "url": "https://apihandyman.io/toolbox/api-developer-weekly-newsletter/",
    "banner": "https://apihandyman.io/images/toolbox/api-developer-weekly-newsletter/banner.png",
    "description": "Hundreds if not thousand of websites talk about APIs, I rely on James Higginbotham‚Äôs newsletter to stay up to date about what is happening in the API space thanks to his weekly selection of great posts.",
    "body": "Hundreds if not thousand of websites talk about APIs, I rely on James Higginbotham‚Äôs newsletter to stay up to date about what is happening in the API space thanks to his weekly selection of great posts.The API Developer Weekly is a weekly newsletter hyper-focused on the business, design, development, and deployment of APIs for web and mobile apps."
},{
    "id": "1",
    "type": "tool",
    "title": "Toolbox - API Evangelist",
    "url": "https://apihandyman.io/toolbox/apievangelist/",
    "banner": "https://apihandyman.io/images/toolbox/apievangelist/banner.png",
    "description": "API Handyman wouldn‚Äôt exist without the API Evangelist. It‚Äôs always a pleasure to read Kin Lane‚Äôs views on the API space. This site is a hyper-mega-huge source of information about ALL aspects of APIs from API definitions to monetization and governance and dozens of other topics.",
    "body": "API Handyman wouldn‚Äôt exist without the API Evangelist. It‚Äôs always a pleasure to read Kin Lane‚Äôs views on the API space. This site is a hyper-mega-huge source of information about ALL aspects of APIs from API definitions to monetization and governance and dozens of other topics.API Evangelist is a site dedicated to the technology, business, and politics of APIs. Beginning as a research site studying many different types of APIs, and then evolving towards developing an understanding of the common building blocks API providers are using across the API lifecycle."
},{
    "id": "2",
    "type": "tool",
    "title": "Toolbox - API Stylebook",
    "url": "https://apihandyman.io/toolbox/apistylebook/",
    "banner": "https://apihandyman.io/images/projects/apistylebook-1280-400.png",
    "description": "I started this project with a simple API Design Guidelines list in mind and ended with a fully analyzed collection of API design guidelines. I created it for others but I use it myself too. When I wonder how to handle some API design matters, I select the related topic and read how others handle it. To be honest, it needs some refresh, it is a real pain to update and maintain and could be more user friendly; that‚Äôs on my todo list.",
    "body": "I started this project with a simple API Design Guidelines list in mind and ended with a fully analyzed collection of API design guidelines. I created it for others but I use it myself too. When I wonder how to handle some API design matters, I select the related topic and read how others handle it. To be honest, it needs some refresh, it is a real pain to update and maintain and could be more user friendly; that‚Äôs on my todo list. The API Stylebook aims to help API Designers find answers to API design questions and build their own API design guidelines by providing quick and easy access to categorized and analyzed API Design Guidelines."
},{
    "id": "3",
    "type": "tool",
    "title": "Toolbox - JQ",
    "url": "https://apihandyman.io/toolbox/jq/",
    "banner": "https://apihandyman.io/images/toolbox/jq/banner.png",
    "description": "Ever wanted to quickly find, extract or modify data coming from some JSON documents on the command line? JQ is the tool you‚Äôre looking for. I use it every time I need to tranform, modify or extract some properties from an API‚Äôs response or analyze OpenAPI specification JSON files during my API reviews.",
    "body": "Ever wanted to quickly find, extract or modify data coming from some JSON documents on the command line? JQ is the tool you‚Äôre looking for. I use it every time I need to tranform, modify or extract some properties from an API‚Äôs response or analyze OpenAPI specification JSON files during my API reviews.JQ is like sed for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that sed, awk, grep and friends let you play with text."
},{
    "id": "4",
    "type": "tool",
    "title": "Toolbox - Net API Events",
    "url": "https://apihandyman.io/toolbox/net-api-events/",
    "banner": "https://apihandyman.io/images/toolbox/net-api-events/banner.png",
    "description": "Thanks to Matthew Reinbold‚Äôs Net API events, I stay up to date regarding upcoming API related conferences.",
    "body": "Thanks to Matthew Reinbold‚Äôs Net API events, I stay up to date regarding upcoming API related conferences. The Latest Upcoming, In-Person API Events. Events are culled from Twitter hearsay, select Meetup.com groups, and/or directly from kind individuals looking to grow their community. Have something not listed here? Submit an event!"
},{
    "id": "5",
    "type": "tool",
    "title": "Toolbox - Net API Notes Newsletter",
    "url": "https://apihandyman.io/toolbox/net-api-notes-newsletter/",
    "banner": "https://apihandyman.io/images/toolbox/net-api-notes-newsletter/banner.png",
    "description": "I always read Matthew Reinbold‚Äôs Net API Notes Newsletter with delight. It‚Äôs not just a bunck of links; every week Matthew actually writes a letter in which he shares his thoughts accompanied with links to relevant posts of the past week.",
    "body": "I always read Matthew Reinbold‚Äôs Net API Notes Newsletter with delight. It‚Äôs not just a bunck of links; every week Matthew actually writes a letter in which he shares his thoughts accompanied with links to relevant posts of the past week.Keeping up with every single API tidbit and microservice dalliance that pops up on the web can be time consuming. Net API Notes, an email newsletter from the curator of NetAPI.events, is a semi-regular digest of only the must-have insights."
},{
    "id": "6",
    "type": "tool",
    "title": "Toolbox - Newman",
    "url": "https://apihandyman.io/toolbox/newman/",
    "banner": "https://apihandyman.io/images/toolbox/newman/banner.png",
    "description": "Newman is the command line counter part of Postman. I use it to run Postman‚Äôs collection in the terminal, especially to batch API calls based on CSV data.",
    "body": "Newman is the command line counter part of Postman. I use it to run Postman‚Äôs collection in the terminal, especially to batch API calls based on CSV data."
},{
    "id": "7",
    "type": "tool",
    "title": "Toolbox - OpenAPI Map",
    "url": "https://apihandyman.io/toolbox/openapi-map/",
    "banner": "https://apihandyman.io/images/projects/openapimap-1280-400.png",
    "description": "I built the OpenAPI map because I was constantly searching for ‚Äúhow do this with the OpenAPI spec‚Äù and also ‚Äúbut where is that thing‚Äù in the specification. Having the OpenAPI specification represented as a tree given essential information and quick access to source documentation of each element saved me countless time.",
    "body": "I built the OpenAPI map because I was constantly searching for ‚Äúhow do this with the OpenAPI spec‚Äù and also ‚Äúbut where is that thing‚Äù in the specification. Having the OpenAPI specification represented as a tree given essential information and quick access to source documentation of each element saved me countless time.The OpenAPI map helps people find their way in the OpenAPI Specification. It provides a simple view of the specification and an easy access to the documentation of all of its elements."
},{
    "id": "8",
    "type": "tool",
    "title": "Toolbox - OpenAPI Specification",
    "url": "https://apihandyman.io/toolbox/openapi-specification/",
    "banner": "https://apihandyman.io/images/toolbox/openapi-specification/banner.png",
    "description": "Without the OpenAPI Specification (fka. Swagger Specification), my job would be a total nightmare. It is a machine readable API description format that I use when I design APIs, when reviewing API designs, documentating APIs, checking that implementation conforms to design and build implementation.",
    "body": "Without the OpenAPI Specification (fka. Swagger Specification), my job would be a total nightmare. It is a machine readable API description format that I use when I design APIs, when reviewing API designs, documentating APIs, checking that implementation conforms to design and build implementation."
},{
    "id": "9",
    "type": "tool",
    "title": "Toolbox - Postman",
    "url": "https://apihandyman.io/toolbox/postman/",
    "banner": "https://apihandyman.io/images/toolbox/postman/banner.png",
    "description": "I use Postman to do API call when I learn to use a new API. It‚Äôs also very powerful and convenient to document API, I try to always have a Postman collection in the code repositories of the APIs I build. It‚Äôs runner feature is incredibly useful to batch API calls with data coming from CSV files.",
    "body": "I use Postman to do API call when I learn to use a new API. It‚Äôs also very powerful and convenient to document API, I try to always have a Postman collection in the code repositories of the APIs I build. It‚Äôs runner feature is incredibly useful to batch API calls with data coming from CSV files."
},{
    "id": "10",
    "type": "tool",
    "title": "Toolbox - Spectral",
    "url": "https://apihandyman.io/toolbox/spectral/",
    "banner": "https://apihandyman.io/images/toolbox/spectral/banner.png",
    "description": "I use Spectral while designing APIs and during API design reviews. It is a JSON/YAML linter with built-in support for OpenAPI 2 and 3 (and also AsyncAPI). I use it to check that API designs conform to my guidelines and also to spot unusual design patterns that needs to be discussed with the people in charge of the API. It really speeds up my reviews and help me avoid oversights.",
    "body": "I use Spectral while designing APIs and during API design reviews. It is a JSON/YAML linter with built-in support for OpenAPI 2 and 3 (and also AsyncAPI). I use it to check that API designs conform to my guidelines and also to spot unusual design patterns that needs to be discussed with the people in charge of the API. It really speeds up my reviews and help me avoid oversights."
},{
    "id": "11",
    "type": "tool",
    "title": "Toolbox - Studio",
    "url": "https://apihandyman.io/toolbox/studio/",
    "banner": "https://apihandyman.io/images/toolbox/studio/banner.png",
    "description": "I use Spectral while designing APIs and during API design reviews. It is API an design UI that supports OpenAPI 2 and 3. It comes with a totally awesome Spectral (OpenAPI linter) integration. The UI does not cover all features of the OpenAPI formats, but it‚Äôs not a problem for most users: this is the most complete and the best tool of his kind. And I love being able to switch between UI and code views (this also helps to do what you can‚Äôt do with the UI).",
    "body": "I use Spectral while designing APIs and during API design reviews. It is API an design UI that supports OpenAPI 2 and 3. It comes with a totally awesome Spectral (OpenAPI linter) integration. The UI does not cover all features of the OpenAPI formats, but it‚Äôs not a problem for most users: this is the most complete and the best tool of his kind. And I love being able to switch between UI and code views (this also helps to do what you can‚Äôt do with the UI)."
},{
    "id": "12",
    "type": "tool",
    "title": "Toolbox - Technology Radar",
    "url": "https://apihandyman.io/toolbox/thoughtworks-technology-radar/",
    "banner": "https://apihandyman.io/images/toolbox/thoughtworks-technology-radar/banner.png",
    "description": "Thoughtworks is a quite famous software consultancy company, brilliant minds such as Martin Fowler are working there. Every 6 months, they publish their Technology Radar that I enjoy reading to discover new trends, techniques and tools and also to confront my own views to theirs about topics I‚Äôm already aware of.",
    "body": "Thoughtworks is a quite famous software consultancy company, brilliant minds such as Martin Fowler are working there.Every 6 months, they publish their Technology Radar that I enjoy reading to discover new trends, techniques and tools and also to confront my own views to theirs about topics I‚Äôm already aware of.  The Radar is a document that sets out the changes that we think are currently interesting in software development - things in motion that we think you should pay attention to and consider using in your projects. It reflects the idiosyncratic opinion of a bunch of senior technologists and is based on our day-to-day work and experiences. While we think this is interesting, it shouldn‚Äôt be taken as a deep market analysis."
},{
    "id": "13",
    "type": "tool",
    "title": "Toolbox - Web Concepts",
    "url": "https://apihandyman.io/toolbox/webconcepts/",
    "banner": "https://apihandyman.io/images/toolbox/webconcepts/banner.png",
    "description": "If you wonder what means a 418 HTTP status code or which RFC defines the txn JWT claim, Web concepts is what you‚Äôre looking for. I just stopped doing HTTP/web/RFC related search, I now always check Erik Wilde‚Äôs web concepts first and usually find what I‚Äôm looking for instantly. Icing on the cake, all data is also available in JSON format.",
    "body": "If you wonder what means a 418 HTTP status code or which RFC defines the txn JWT claim, Web concepts is what you‚Äôre looking for. I just stopped doing HTTP/web/RFC related search, I now always check Erik Wilde‚Äôs web concepts first and usually find what I‚Äôm looking for instantly. Icing on the cake, all data is also available in JSON format.The Web‚Äôs Uniform Interface is based on a large and growing set of specifications. These specifications establish the shared concepts that providers and consumers of Web services can rely on. Web Concepts is providing an overview of these concepts and of the specifications defining them."
},{
    "id": "14",
    "type": "post",
    "title": "Pink Fluffy Unicorn API? WTF? (or 3 reasons why choosing a not meaningful API name can be a problem)",
    "url": "https://apihandyman.io/pink-fluffy-unicorn-api-wtf-or-3-reasons-why-choosing-a-not-meaningful-API-name-can-be-a-problem/",
    "banner": "https://apihandyman.io/images/pink-fluffy-unicorn-api-wtf-or-3-reasons-why-choosing-a-not-meaningful-API-name-can-be-a-problem/banner.jpg",
    "description": "It is usually considered a terrible practice to name a property ot a function with a meaningless name when writing code. But surprisingly, when it comes to choosing application or API name, some people tend to choose names in a more artistic way (says the ‚ÄúAPI Handyman‚Äù who can name some tool ‚ÄúOpenAPI Chainsaw‚Äù). So let‚Äôs see 3 reasons why choosing a not meaningful API name can be a problem.",
    "body": "It is usually considered a terrible practice to name a property ot a function with a meaningless name when writing code.But surprisingly, when it comes to choosing application or API name, some people tend to choose names in a more artistic way (says the ‚ÄúAPI Handyman‚Äù who can name some tool ‚ÄúOpenAPI Chainsaw‚Äù).So let‚Äôs see 3 reasons why choosing a not meaningful API name can be a problem.This post is a follow up of a tweet I did a few weeks ago: ‚ÄúPink Fluffy Unicorn‚Äù is a cute but totally wrong name for an API unless it actually deals with pink fluffy unicorns. Please choose a meaningful name that tells what the API does.Someone asked some arguments to back this statement because they seem to have to deal with such cute but counter-productive if not dangerous naming strategy.And I realized that I have never formalized my thoughts on this topic, hence this post (thanks so much Twitter people!)Very special thanks to @mrlapingdesign for drawing this post‚Äôs banner.It needs explanationsFirst and most obvious reason why choosing a not totally meaningful name is a terrible idea: it needs explanations.When starting a new job in a another company/organization, don‚Äôt you ever have grumbled when discovering that all internal tools such as the credential manager or the leave management tool have totally awkward not obvious names?Of course, after someone explained you all that (for the 99th time) and if you use them everyday, you may remember their names.But your new colleague, who arrived a few months later, will also struggle to understand what does what at the beginning.And someone will have to explain all that (again, for the 100th time).And if you don‚Äôt use them often, you‚Äôll forget their name and struggle to find them when you desperately need them.And that applies to anything, including APIs.If I‚Äôm looking for the API managing users, I will not search for Pink Fluffy Unicorn API.And if I‚Äôm looking for the API managing file transfers, I will not search for Blue Fluffy Unicorn API.When I see a Pink Fluffy Unicorn API, I have absolutely no clue about what it does by just reading its name, and that is really annoying.Of course, some may object that I could use our awesome API catalog search engine or read the documentation to see that, so using such a not so meaningful name may not be such a big problem.Maybe, so let‚Äôs see the second reason, which is major no-go for me.It does not set boundariesSecond reason why choosing a not totally meaningful name is a terrible idea: it does not set boundaries.And that‚Äôs a major concerns.Indeed, a well defined and designed API is supposed to be a independent set of operations covering a meaningful set of related use cases.If this set of operations don‚Äôt have a meaningful name such as User but is named Pink Fluffy Unicorn, what stops someone to add new features related to a completely different topic such as file transfers?What stops someone transforming this well defined API into a big ball of mud, a do-it-all API that will make no sense at all and be more complex to maintain?What stops someone to create a dangerous mixtures composed of internal facing and external facing operations.Not its name.Some experienced API designers and developers having working in the team for quite a long time, taking their time to think, actually knowing the purpose of the Pink Fluffly Unicorn, probably won‚Äôt do such a mistake but what about beginners or people in a rush?Using a meaningful name creates boundaries that will make most people think twice before adding new features into an API while a meaningless name will open doors to anything.It is possibly a sign of API design smell    Ce que l'on con√ßoit bien s‚Äô√©nonce clairement, Et les mots pour le dire arrivent ais√©ment (What is well understood is clearly stated, And the words to say it come easily)        Nicolas Boileau-Despr√©aux, L'art po√©tique    The third reason why choosing a not totally meaningful name is a terrible idea is a corollary to the second one: it can be a sign of API design smell.Did you choose a meaningless name because you‚Äôre actually unable to find a meaningful one?We all know that choosing names is hard, but if you are really struggling to find a meaningful name for your API, your API Designer senses should tell you that there‚Äôs something wrong. That could mean your API is not solving the good problem, or solving too much problems or not enough of them.Easily finding a meaningful name can comfort your vision of the use case/problems you‚Äôre trying to solve with it.Sometimes you have to deal with itThere are cases where a domain, a team or a tool has a not so meaningful name that you would like to keep for reasons such as not totally changing people habits.Indeed, some people working there for a long time know what means Pink Fluffy Unicorn.So how to satisfy newcomers and seasoned colleagues?In such a case you can use a middle ground approach and name your API(s) ‚ÄúPink Fluffy Unicorn - Meaningful Name‚Äù.That way you ensure seasoned colleagues won‚Äôt be surprised.But most important you ensure that your API surface (your APIs) is well defined (not a big ball of mud) and understandable by newcomers.Icing on the cake, you also ensure that people easily connect APIs together which can be interesting in a big organization or when providing public/partner APIs (‚ÄúTwilio‚Äù doesn‚Äôt mean anything to me but I can get what the ‚ÄúTwilio Messaging API‚Äù does)."
},{
    "id": "15",
    "type": "post",
    "title": "Choosing HTTP status codes Series - Part 4 - Empty list, HTTP status code 200 vs 204 vs 404",
    "url": "https://apihandyman.io/empty-lists-http-status-code-200-vs-204-vs-404/",
    "banner": "https://apihandyman.io/images/empty-lists-http-status-code-200-vs-204-vs-404/banner.png",
    "description": "When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context. This fourth post answers the following question: given that /users is a collection (a list) and no users are named Spock, what should return GET /users?name=spock? 200 OK, 204 No Content or 404 Not Found",
    "body": "When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context.This fourth post answers the following question: given that /users is a collection (a list) and no users are named Spock, what should return GET /users?name=spock? 200 OK, 204 No Content or 404 Not Found      Choosing HTTP status codes Series                      When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context.I never remember in which RFCs HTTP status codes are defined.To get a quick access to their documentation, I use Erik Wilde's Web Concepts.Very special thanks to all Twitter people participating to the #choosehttpstatuscode polls and discussions                                                      1 - This is not the HTTP method you're looking for, HTTP status code 404 vs 405 vs 501                                      2 - Hands off that resource, HTTP status code 401 vs 403 vs 404                                      3 - Move along, no resource to see here (truly), HTTP status code 204 vs 403 vs 404 vs 410                                      4 - Empty list, HTTP status code 200 vs 204 vs 404                                      The contextWhen you need to represent lists (aka collection resources) in a REST/RESTful/RESTish API, a usual design pattern is to represented with them a /resources (or /resource, read /resources rules and /resource sucks ‚Ä¶ or is it the other way around?).More often than not, you‚Äôll need to be able to return a subset of the list‚Äôs elements.To do so, a usual (if not standard) design pattern is to add query parameters to provide search filters.If a GET /users is supposed to return a list containing all (actually accessible to the consumer and possibly to the end user) users, a GET /users?name=spock is supposed to return a list containing only the users whose name is spock.The question we will answer today basically is: which HTTP status code respond with when returning an empty list.            According to my Twitter pool, 51% of respondents would return a 200 OK, while 24% would return a 204 No Content and 25% would return a 404 Not Found.Let‚Äôs see what could be the correct answers according to RFC(s) and common practice.The obvious 200 OK    The 200 (OK) status code indicates that the request has succeeded.        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.3.1    Let‚Äôs start with the most common and valid response in such a case: 200 OK.When responding to GET /users, the API will respond with that HTTP status code along with a list of all (actually accessible to the consumer and possibly to the end user) users users.When responding to GET /users?name=smith, the API will respond also that with HTTP status code along with a list contains all users named smith.And finally when responding to GET /users?name=spock and if there are no user name spock, the API will respond yet another time with that HTTP status code but this time along with an empty list.That is actually the most common response I have ever seen, probably because most people consider that the /users collection/list resource exists and name query param is used to filter the content of the list.But there is a more specific HTTP status code that could do the trick too.The not so current 204    The 204 (No Content) status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.3.5    While 200 OK being a valid and the most common answer, returning a 204 No Content could make sense as there is absolutely nothing to return.It is indeed more often used when responding to a PUT (replace) or a PATCH (partial update), when servers don‚Äôt want to bother returning the replaced/updated resource or on a DELETE because there is usually nothing to return after a deletion.But it can be used on a GET too.If the request is valid, has been successfully fulfilled and if there is no additional content to send (which is the case as the returned list would be empty),  204 No Content is perfectly understandable and valid answer.It‚Äôs a valid response but I personally will not use it and do not recommend to use it in that case in my context.Because it is not that common (based on my experience, it‚Äôs not absolute truth) and may imply more work.Actually, I try to avoid using specific/uncommon HTTP status when a more generic/common one works too, that usually simplifies consumer‚Äôs job and also designer‚Äôs one as there are less possible choices and behaviors (I‚Äôll write a post about that).Though a consumer must be able to interpret any 2xx as as success and fallback to treat it as 200 OK, that means there will be no response body, so no empty list.That could easily lead to to possible ‚Äúnull pointer exception‚Äù or any equivalent requiring more controls in code.A 200 OK with an empty list can be treated the same as non empty list without thinking about it.Note that, consumer may obviously have to check il the list is empty or not to possibly show a message to end user, but the exact same code will work without that control.But while simplifying choices, note that using that ‚Äúsimplified HTTP‚Äù stance, you‚Äôll loose some ‚ÄúHTTP semantic out of the box‚Äù. Indeed tne major argument in favor of 204 No Content is that is allows to check empty search results (especially in logs) vs non empty ones without relying on specific response body‚Äôs semantic.That‚Äôs quite an interesting feature.Maybe we need more APIs actually fully using HTTP semantic to make this 204 No Content response more common and a no brainer.So choosing between 200 OK and 204 No Content, depends on you and your context.The not recommended 404    The 404 (Not Found) status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.5.4    I just realized that‚Äôs the fourth post in this series and 404 Not Found has been involved in all posts so far.Let‚Äôs see what say the HTTP RFCs (with an s) about using it in that use case.If we look at this status code definition in RFC 7231 and if we consider that /users is the resource used even when doing a GET /users?name=spock, returning that HTTP status code makes no sense at all because the resource /users exists, it‚Äôs just that the list it contains may be empty.But is this definition of a resource identifier (excluding query parameters) is actually the correct one?Section 2 of RFC 7231 states each resource is identified by a Uniform Resource Identifier (URI), as described in Section 2.7 of RFC 7230.That section 2.7 of RFC 7230 says the ‚Äúquery‚Äù (what is between the first ? and #) is a part of the resource identifier.If we follow the link (it‚Äôs quite a maze!) conducting to complete description of the query, we eventually arrive at Section 3.4 of RFC 3986 that says the query component contains non-hierarchical data that, along with data in the path component (Section 3.3), serves to identify a resource.That basically means that /users?name=spock is a resource identifier, so returning 404 is valid according to HTTP RFCs if we want to say ‚Äúsorry no resource match the strict identifier provided in your query‚Äù or ‚Äúthere is no such a users list containing users named spock‚Äù.But using that HTTP status code being valid from a pure HTTP perspective, is it actually a good idea to use it in that use case?In my humble opinion, based on my experience designing APIs, reading and listening to many API practitioners, analyzing many APIs and doing hundreds of API design reviews, I do not recommend to use it in that case because that would break a common practice.In most REST/RESTful/RESTish APIs, a ‚Äúresource identifier‚Äù is actually the resource path without the query part, that may be wrong when speaking strictly HTTP but that is the current state of common practice.In most APIs, 404 Not Found is strongly attached to ‚Äúthere is nothing for the requested path (excluding query parameters)‚Äù.It is returned in case involving /path-that-does-not-exist or /collection/{id that does not exist} (see Choosing HTTP status codes Part 2 - Hands off that resource, HTTP status code 401 vs 403 vs 404 or Choosing HTTP status codes Part 3 - Move along, no resource to see here (truly), HTTP status code 204 vs 403 vs 404 vs 410) but not for empty lists (that‚Äôs usually a 2xx Success class).Also, returning a 4xx Client Error Class says that consumer made an error, is that really the case here?I don‚Äôt think so, the consumer just provided search filters that don‚Äôt match any element in a list.That‚Äôs my reasoned opinion of not using 404 Not Found for empty lists, but if you have valid reasons to use this HTTP status code for this use case, don‚Äôt forget to be consistent and provide informative error feedback.Indeed, if we take for granted that GET /users?name=spock returns a 404 Not Found if there are no users named spock.What about GET /users if there are no users at all? It should return the same HTTP status code.And differentiating this it from a more common /path-that-does-not-exist will require to add some information in the response body to explain the actual cause of this response.DX above allThe lesson of today is that following the HTTP protocol is one thing but there are sometimes various options with pros and cons and sometimes being overly strict can lead to design that are less easy to understand.The question is not about achieving the most perfect design (regarding HTTP) but just achieve a design that makes sense for most people involved and proposes the best as possible DX.And that D in DX includes developers but also designers.Simple design rules that makes sense for most are a key factor in your APIs success."
},{
    "id": "16",
    "type": "post",
    "title": "Generating OpenAPI Descriptions. When is it a good idea?",
    "url": "https://apihandyman.io/generating-openapi-descriptions-when-is-it-a-good-idea/",
    "banner": "https://apihandyman.io/images/generating-openapi-descriptions-when-is-it-a-good-idea/banner.jpg",
    "description": "As a follow up of my ‚Äú6 reasons why generating OpenAPI sucks‚Äù post, I had the pleasure to talk about ‚Äúis it a good idea to generate OpenAPI descriptions?‚Äù with Erik Wilde. In this discussion, we answer this questions at various stages of the API lifecycle: design time, code time, and runtime.",
    "body": "As a follow up of my ‚Äú6 reasons why generating OpenAPI sucks‚Äù post, I had the pleasure to talk about ‚Äúis it a good idea to generate OpenAPI descriptions?‚Äù with Erik Wilde. In this discussion, we answer this questions at various stages of the API lifecycle: design time, code time, and runtime.Watch on Erik Wilde‚Äôs Youtube Channel"
},{
    "id": "17",
    "type": "post",
    "title": "/resources rules and /resource sucks ... or is it the other way around?",
    "url": "https://apihandyman.io/resources-rules-and-resource-sucks-or-is-it-the-other-way-around/",
    "banner": "https://apihandyman.io/images/resources-rules-and-resource-sucks-or-is-it-the-other-way-around/banner.png",
    "description": "Using singular or plural to represent a list of something is an old debate in computer science, especially in the database field. But what about APIs then? It‚Äôs still the same, if you look at various APIs, you‚Äôll see that something like ‚Äúlist/search resources‚Äù could be either represented by a GET /resources or a GET /resource. Who is right? Who is wrong? I have a preference, you may have another, but should we really give importance to such a debate? Aren‚Äôt we missing something? Let‚Äôs investigate that topic and discover what‚Äôs really important when choosing collection resource path.",
    "body": "Using singular or plural to represent a list of something is an old debate in computer science, especially in the database field.But what about APIs then?It‚Äôs still the same, if you look at various APIs, you‚Äôll see that something like ‚Äúlist/search resources‚Äù could be either represented by a GET /resources or a GET /resource.Who is right?Who is wrong?I have a preference, you may have another, but should we really give importance to such a debate?Aren‚Äôt we missing something?Let‚Äôs investigate that topic and discover what‚Äôs really important when choosing collection resource path.Is there a ‚Äúright‚Äù REST solution?Regarding choosing between /customer and /customers, I often meet people who ask me ‚Äúis whatever solution RESTful?‚Äù which basically means ‚Äúwhat is the right solution?‚Äù.When doing a choice, I always try to refer to a RFC, standard or common practice in order to make the ‚Äúright‚Äù choice.So, let‚Äôs see what the REST Architectural Style dissertation says about that.In short, REST is an architectural style which has been created by Roy Fielding to explain how distributed applications should interact with each other.He did that to explain how the HTTP protocol work and analyze factually the impact of its possible evolutions.Actually, he chose to describe factually a model and confront others ideas to this model, rather than just saying ‚Äúmy way is the best‚Äù, which is something that we all should think about.This architectural style defines a set of constraints (client/server separation, statelessness, cacheability, layered system, uniform interface and code on demand)that a REST system must conforms to.REST APIs (or RESTful) APIs are supposed to embrace the REST Architectural Style and its constraints.Actually, this more often than not means those APIs try to conform more or less to HTTP semantic without thinking too much about all REST constraints.Speaking of constraints, does Mr Fielding dissertation talks about choosing resources paths?Resource paths (or resource identifiers) are not precisely identified as a constraint but there are some guidance provided:    The definition of resource in REST is based on a simple premise: identifiers should change as infrequently as possible. Because the Web uses embedded identifiers rather than link servers, authors need an identifier that closely matches the semantics they intend by a hypermedia reference, allowing the reference to remain static even though the result of accessing that reference may change over time. REST accomplishes this by defining a resource to be the semantics of what the author intends to identify, rather than the value corresponding to those semantics at the time the reference is created. It is then left to the author to ensure that the identifier chosen for a reference does indeed identify the intended semantics.        Roy Fielding, Architectural Styles and the Design of Network-based Software Architectures    For what matters in this post, this could be summarized by saying resource identifiers (or path) should change as infrequently as possible and it is up to the author to choose the most adapted semantics.So as you can see, nothing about singular or plural, according to the REST architectural style, it‚Äôs up to us to choose as long as it means something.What is sure: don‚Äôt do bothSo according to REST principles, /resources or /resource, you can choose the one you like.But you have to choose one, you can‚Äôt use both, for the sake of consistency and predictability.Indeed, it would be quite awkward to do GET /customers to search or list customers and a GET /order to list orders.APIs are supposed to be consistent with themselves and other APIs of the same domain/organization.Choose one format, write it down in your API design guidelines and ensure that everyone designing APIs in your organization stick to this choice.And for those who would come to the idea of using GET /customers to search or list customers and a GET /customer/{customerId} to read a specific customer, because ‚Äúoh, we are reading a single element so let‚Äôs go singular now‚Äù.Please don‚Äôt do that.If people do a GET /whatever to get a list of whatever they‚Äôre used to brainlessly do a GET /whatever/{whateverId} to get a specific element.You‚Äôll disturb many people by breaking habits.But there are more than habits involved here, doing that simply breaks the semantic of paths.In a file system, do folder names change when you target a file inside them?In a database, do you change table name when doing a select * where id=whateverId?No.So, please chose one side or the other, no middle ground here.My reasoned opinion: pluralI use plural names for collections mostly because of semantics: plural means ‚Äúit contains multiple elements‚Äù. Note that I use plural in both path (/customers is a path of collection resource) but also in data models (customers is a property representing a list of customers inside a data model).Using plural name for a collection also avoid surprise when having singleton resources, for instance GET /customers/{customerId}/address, I know by reading this that I‚Äôll manipulate a single address and not a list of address.That‚Äôs the main reason why I‚Äôm not using singular.Using singular for collection name would make that less obvious, though the data returned by a GET /customer/{customerId}/address would give more than a hints about what is actually returned (list or single element).But that requires to trigger a read operation call to know that (if we don‚Äôt rely on documentation at all).But let‚Äôs be objective, the plural option is not without drawbacks.Obviously as a machine getting data containing a customerId (singular) and trying to guess how the API work without taking advantage of the documentation, I have some work to do to ‚Äúknow‚Äù that the plural of customer is customers in order to try a GET /customers/{customerId} (which is quite simple here but determine singular or plural is not always that simple).But if your API is a true REST API that shouldn‚Äôt be a problem because it provides the ready to use links to other resources.Problem solved if that‚Äôs actually a problem, which is not the case most of the time.Indeed most people don‚Äôt care about hypermedia nor automatic API discovery and rely on the API documentation to write code that actually use the API (even for testing).Regarding the singular option, I also wonder how then would be called a customer list inside a data model?I would probably add a suffix (customerList) but then that introduce inconsistency between path and data, that is another reason why I prefer the plural option.The truth is elsewhereI think the lesson to learn here is not determining which one is ‚Äúbetter‚Äù between /resources and /resource, I‚Äôm sure someone using singular name has plenty of good reason doing so.No, the lesson here is that when there is non refutable standard solution, you have to reason to choose one that makes sense.Avoid ‚Äújust because‚Äù solutions that you can‚Äôt explain.Avoid at all costs ‚Äúwtf‚Äù solutions (like GET /customers + GET /customer/{customerId}) introducing complexity or inconsistency.And don‚Äôt forget to put it in your guidelines and ensure that everyone in your organization stick to that decision for the sake of consistency."
},{
    "id": "18",
    "type": "post",
    "title": "Choosing HTTP status codes Series - Part 3 - Move along, no resource to see here (truly), HTTP status code 204 vs 403 vs 404 vs 410",
    "url": "https://apihandyman.io/move-along-no-resource-to-see-here-seriously-http-status-code-204-vs-403-vs-404-vs-410/",
    "banner": "https://apihandyman.io/images/move-along-no-resource-to-see-here-seriously-http-status-code-204-vs-403-vs-404-vs-410/banner.png",
    "description": "When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context. This third post answers the following question: given that resource with id 123 actually doesn‚Äôt exist in the underlying database, what should be the response to GET /resources/123 when consumer is allowed to access such ressource? 204 No Content, 403 Forbidden, 404 Not Found or 410 Gone?",
    "body": "When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context. This third post answers the following question: given that resource with id 123 actually doesn‚Äôt exist in the underlying database, what should be the response to GET /resources/123 when consumer is allowed to access such ressource? 204 No Content, 403 Forbidden, 404 Not Found or 410 Gone?      Choosing HTTP status codes Series                      When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context.I never remember in which RFCs HTTP status codes are defined.To get a quick access to their documentation, I use Erik Wilde's Web Concepts.Very special thanks to all Twitter people participating to the #choosehttpstatuscode polls and discussions                                                      1 - This is not the HTTP method you're looking for, HTTP status code 404 vs 405 vs 501                                      2 - Hands off that resource, HTTP status code 401 vs 403 vs 404                                      3 - Move along, no resource to see here (truly), HTTP status code 204 vs 403 vs 404 vs 410                                      4 - Empty list, HTTP status code 200 vs 204 vs 404                                      The contextLet‚Äôs say your are creating an API for a library, obviously you‚Äôll design a GET /books to search for books and a GET /books/{isbn} to get detailed information about a book.You did use an International Standard Book Number because such a unique and universally known id is far more convenient than an opaque bookId generated by your implementation.Indeed using standard/well known values for resource identifiers makes an API more interoperable and usable in other contexts than yours.Design digression is over, let‚Äôs get back to the true topic of this post: choosing an HTTP status code.A library may not own all books that have been published on earth , end users may also simply mistype an ISBN or books may have been removed from the library.What should be the response to a GET /books/{not known, totally wrong or not present anymore ISBN}?            According to my (vague) Twitter poll (which was not explicitly talking about the removed use case), 94% of respondents would return a 404 Not Found, while 4% would return a 403 Forbidden and 2% would return a 410 Gone.Note also that, in the discussion, some people mentioned returning a 204 No Content.Let‚Äôs see what could be the correct answer(s) according to RFCs.No brainer, use 404    The 404 (Not Found) status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.5.4    Let‚Äôs start with what is the most common and valid response in such a case: 404This HTTP status code reason Not Found is both obvious and actually means what everybody thinks it means (which is not always the case).In our case a GET /books/{totally wrong ISBN} must return a 404And that must be your favorite response when consumer is requesting something that doesn‚Äôt exist, not only because RFC 7231 says so, but also because people are used to get that response in such a case.Being consistent with the rest of the world is a rule of thumb when building APIs (or whatever).Though people are used to it, there can be some subtleties that requires a more specific HTTP status code when signifying ‚Äúthat doesn‚Äôt exist‚Äù.Has existed and can do something about it, you may use 410    The 410 (Gone) status code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.5.9    In our case a GET /books/{\"book that once has been in library but is no more\" ISBN} could return such a status code, especially if the end user is a librarian who deleted a book by mistake.Digression: A regular library user may get a 404 Not Found for the same request.That means that your API may return different responses depending on who is the consumer/end/user.Your database state is not your API data state, the data returned by an API may not be exactly how they actually are in the underlying database (we already have seen that in previous post).It‚Äôs not unusual to use a soft delete when removing something from a database and so simply flag it as ‚Äúdeleted‚Äù but keeping the data.There are many reasons to do that, regulations like GDPR may force you to do so (though you should move such data in another database) or you may want to propose an ‚Äúundo‚Äù possibility.A 410 could also be a good response to a request made on an expired temporary URL (that was valid only for a short period of time, that reminds me to write a post about signed URLs).Whatever the reason of signifying that something actually existed, you may return a 410 Gone if and only if consumers can do something about it (like undoing something or requesting a new temporary URL). But in that case you should provide information about what they can do about it and how (in response body or at least in documentation).No scopes, rights or privilege involved, don‚Äôt use 403    The 403 (Forbidden) status code indicates that the server understood the request but refuses to authorize it.  A server that wishes to make public why the request has been forbidden can describe that reason in the response payload (if any).        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.5.3    In our library use case there are no scopes/privileges/rights involved, a GET /books/{wrong ISBN} will never ever return a 403 Forbidden but a 404 Not Found.A GET /books/{has existed ISBN} may return a 410 Gone as seen in previous section.It‚Äôs only after that, when trying to undelete the book, maybe with a PUT /books/{\"book that once has been in library but is no more\" ISBN}, that the response could be a 403 Forbidden if librarian is not allowed to to so.If privileges/rights are involved when accessing resources (either WHATEVER /books/{isbn} in general or a specific WHATEVER /books/{specific isbn}), a 403 may be returned, you should read Choosing HTTP status codes Part 2 - Hands off that resource, HTTP status code 401 vs 403 vs 404 to learn more about that.It‚Äôs a consumer error, don‚Äôt use 204    The 204 (No Content) status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.3.5    Obviously, I didn‚Äôt include 204 No Content in the poll because Twitter only allows 3 choices ‚Ä¶ Well to be honest, though I often meet people wanting to use it that way, I totally forget it for that poll üòÖ (and would probably had propose it instead of 403 Forbidden).The No Content reason may fool you, but the description is quite clear, it doesn‚Äôt mean ‚Äúthere‚Äôs nothing for this path‚Äù but ‚Äúthese is something for this path but not content to return‚Äù.Also that HTTP status is a 2xx Success class, it is not intended to signify that something went wrong which is the case here, consumer did send a non existing/wrong resource id.So you should avoid using it in such a case."
},{
    "id": "19",
    "type": "post",
    "title": "6 reasons why generating OpenAPI from code when designing and documenting APIs sucks",
    "url": "https://apihandyman.io/6-reasons-why-generating-openapi-from-code-when-designing-and-documenting-apis-sucks/",
    "banner": "https://apihandyman.io/images/6-reasons-why-generating-openapi-from-code-when-designing-and-documenting-apis-sucks/banner.png",
    "description": "When working with OpenAPI Specification documents to design and document APIs, there are two approaches: either you write it (directly using a text editor or indirectly using an API design GUI), either you generate it from the implementation‚Äôs code (using annotations). Generating OpenAPI Specification documents from code has major drawbacks that you should be aware of in order to choose this approach knowingly.",
    "body": "When working with OpenAPI Specification documents to design and document APIs, there are two approaches: either you write it (directly using a text editor or indirectly using an API design GUI), either you generate it from the implementation‚Äôs code (using annotations).Generating OpenAPI Specification documents from code has major drawbacks that you should be aware of in order to choose this approach knowingly.If you know me, have seen me talking at conferences, have read my posts or my book, you know what is my favorite approach (spoiler: the ‚Äúwrite it‚Äù one).But as an API design reviewer I work with many different teams: some use the first approach and others the second one and some use both.Slowly but surely, the write it approach is gaining ground.I am pleased to see new teams I have never work with before are already convinced that writing OpenAPI (when design and documenting) is a better approach for them.And I am even more pleased to see some who were using the ‚Äúgenerate it‚Äù approach switching to other other one, convinced by my reasons and the problems their encountered.I thought it could be interesting to share the 6 main reasons why people would stop to use the ‚Äúgenerate it‚Äù approach and switch to the ‚Äúwrite it‚Äù one, hence this post.Complicates designThe first reason is that generating OpenAPI from code complicates design.Indeed, you need to write actual implementation‚Äôs code to get something.You need a fully functional development environment to code and build a more or less empty API‚Äôs implementation‚Äôs skeleton.And not everybody who work on the design of an API can write code.That may be strange to your eyes, but there are places where developers of an API‚Äôs implementation are not the one who will actually design the API, business analysts may have that role.They work closely with developers but they are the one who actually write the API‚Äôs contract.There are places where those people may work more closely together, contributing to the same OpenAPI document, that would be quite complicated to do that with a generated one if one of them don‚Äôt code.Some would argue that ‚Äúwriting‚Äù OpenAPI is like writing code.Until not so long ago, you would need to know the syntax to actually write it, but that‚Äôs not true anymore.There are API design GUI that allows anyone (with basic HTTP knowledge) to describe an API without having to write a single line of YAML (or JSON for the most masochistic).Forces to choose development stackThe second reason is an annoying side effect of having to write actual implementation‚Äôs code to get something.To write code, you actually have to choose a development stack.When you are working on a totally new software solution making such decisions too early during the overall solution‚Äôs design phase may reveal to be a problem.Indeed, you may realize that the chosen stack was not the more adapted one once you have a full view on what the API is supposed to do and so the written code must be thrown to garbage.Obviously if that‚Äôs just ‚Äúyet another API in familiar environment‚Äù, that reason is null and void.Lessens design qualityHaving to write code, especially on an existing application, risks to lessen the API design quality because it may lead to being ‚Äúinside out‚Äù or also less accurate.An inside out API design brutally exposes what is happening under the hood resulting in less easy to understand, less easy to use, less easy to evolve APIs.Seeing existing functions, existing databases, you may be tempted to expose them as is without rethinking them.That will lead to consumers needing to know how your implementation works when they shouldn‚Äôt, leading to tight coupling with them crippling the possibility of evolutions on your side.Being polluted by existing implementation or purely development oriented concerns, not only will you expose the engine that should be hidden but you may take shortcuts resulting in less accurate design.Indeed, for instance, you may choose wrong resources, wrong operations, wrong granularity for an operation or data model or you may simply miss that you should have created a totally new API; all that simply because you were too close to the existing code or data.Such design will obviously also be less easy to understand, less easy to use, less easy to evolve APIs.Casts doubt upon implementationThe big argument of the generate it approach is ‚Äúno need to synchronize spec and code anymore!‚Äù.Yes that‚Äôs true, but that also means you don‚Äôt have an independent source of truth for your API‚Äôs contract.Whats was agreed on during the design phase may not be what is actually implemented in the end.Without a source of truth independent from actual code, there‚Äôs no way to test that what is implement is actually ok.A long time ago, having working with third party contractors building applications for my company that revealed to be a major problem.And even when working with the family, some errors or modifications may happen inadvertently.Complicates writing documentationDevelopers who love to write documentation raise your hands!Not so many hands risen (that‚Äôs a pity, but that‚Äôs another story).This reason is similar to the first one ‚ÄúComplicates design‚Äù.When working on APIs, people who write the documentation may not be the one who write the code (and note also they may not be the one who do the design).Doc writers may not want to write code and developers may not want to have people mingling with their codebase.Lessens documentation qualityYou may not know it but pushing the OpenAPI Specification to its limits allows to write totally awesome API documentation that everyone will love (writing about that is on my to do list).That‚Äôs especially interesting for private APIs, indeed you may not want to do the same level of effort regarding developer portal and producing content.A complete OpenAPI shown in Redoc, Stoplight Elements or even SwaggerUI will do the trick at almost 0 cost.But producing such specification requires to uses all the OpenAPI Specification subtleties and unfortunately not all (if not no) generator allows that (and not all developers are willing to do such effort in their code, because previous reason).You may possibly tweak what the generator does to achieve some interesting modifications but at what cost?Whatever you do, generating code irremediably results in less expressive and less complete OpenAPI documents.So generating OpenAPI sucks?That‚Äôs not what I said, what you should retain from this is is that there are concerns to be aware of when generating OpenAPI Specification from code when designing and documenting API.OK, the post‚Äôs title says ‚Äúsuck‚Äù, that‚Äôs a clickbait (for totally honorable reasons üòÖ).Actually and as always, it‚Äôs not a matter of right or wrong, it‚Äôs a matter of choosing a solution to a given problem according to a context and living with the consequences.If in your context, people who design, code, and document are the same or are ok to work with code.And if people working on design are sufficiently experimented to not be polluted by existing code and data.And if you‚Äôre confident that there will be no variation during implementation.And if you don‚Äôt need all OpenAPI subtleties for your API documentation (and frankly, for private APIs, you can live with that).You may generate your OpenAPI documents from code.If not, you may have to rethink your strategy or if it‚Äôs too complicated decide knowingly to live with the risks listed in this post.And regarding ‚Äúgenerating OpenAPI‚Äù in general there are use cases where it‚Äôs incredibly interesting to do it.But that‚Äôs another story."
},{
    "id": "20",
    "type": "post",
    "title": "Choosing HTTP status codes Series - Part 2 - Hands off that resource, HTTP status code 401 vs 403 vs 404",
    "url": "https://apihandyman.io/hands-off-that-resource-http-status-code-401-vs-403-vs-404/",
    "banner": "https://apihandyman.io/images/hands-off-that-resource-http-status-code-401-vs-403-vs-404/banner.png",
    "description": "When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context. This second post answers the following question: given that resource with id 123 actually exists in the underlying database, what should be the response to GET /resources/123 when consumer is not allowed to access it? 401 Unauthorized, 403 Forbidden or 404 Not Found?",
    "body": "When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context. This second post answers the following question: given that resource with id 123 actually exists in the underlying database, what should be the response to GET /resources/123 when consumer is not allowed to access it? 401 Unauthorized, 403 Forbidden or 404 Not Found?      Choosing HTTP status codes Series                      When designing APIs, choosing HTTP status codes is not always that obvious and prone to errors, I hope this post series will help you to avoid common mistakes and choose an adapted one according to the context.I never remember in which RFCs HTTP status codes are defined.To get a quick access to their documentation, I use Erik Wilde's Web Concepts.Very special thanks to all Twitter people participating to the #choosehttpstatuscode polls and discussions                                                      1 - This is not the HTTP method you're looking for, HTTP status code 404 vs 405 vs 501                                      2 - Hands off that resource, HTTP status code 401 vs 403 vs 404                                      3 - Move along, no resource to see here (truly), HTTP status code 204 vs 403 vs 404 vs 410                                      4 - Empty list, HTTP status code 200 vs 204 vs 404                                      The contextLet‚Äôs say you‚Äôre creating an API for a mobile application that allows people to record phone calls.Once calls are recorded, users can list them and listen to each individual recording.Listing a user‚Äôs recorded calls could be done with a GET /users/{phoneNumber}/calls, for each phone call listed you get a random and unpredictable id that can be used to retrieve the actual audio recording with a GET /calls/{callId}.Basically it means that when a user whose phone number is 123456789 uses the mobile application, the application sends a GET /users/123456789/calls API request to list available recorded calls.The API responds with a 200 OK along with the recorded calls belonging to user.If user taps on one conversation which id is Bnwgab, the application sends a GET /calls/Bnwgab and the API responds with a 200 OK along with the audio fileBut what happens if some curious and maybe malicious user scan network traffic coming out of the application?This hacker will easily understand how this ‚Äúnot so private‚Äù API works.With very little effort, they will succeed to generate phone numbers that actually exist in the underlying system so send GET /users/{phone number of another user}/calls requests.And with more effort, enough patience and adapted tools they may even generate valid random some callId and send GET /calls/{callId that don't belong to their user account} requests.In either case, the API should prevent accessing resources that don‚Äôt belong to the caller and signify there‚Äôs a problem with caller‚Äôs request.Note that if that sounds like a no-brainer for many people, that is actually not always the case and some APIs may return a 200 OK along with the requested data.Regularly, stories such as this one (which inspired the above use case) come out.Never forget that when creating APIs and never refrain from double check that your colleagues are also aware of that.And note also that using PII (Personnally Identifiable Information) or other sensitive data as ids can be very convenient but raises security concerns, especially if they appear in URLs as they can be logged almost everywhere.I should write a post series about API security one day (POST /writing-ideas done!).Let‚Äôs get back to what we are talking about today: HTTP status codes.Obviously, when consumer make an API call on resource that actually exists but don‚Äôt belong to them, the API must respond with a 4xx Client Error Class, but which one could be the more accurate?            According to my Twitter poll, 54% of people would return a 403 Forbidden, while 24% would return a 404 Not Found and also 24% would return a 401 Unauthorized.Let‚Äôs see who is right and who is wrong based on what RFCs say.Use 404 when resource is none of consumer‚Äôs business (and never will)    The 404 (Not Found) status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.5.4    Returning a 404 Not Found means ‚Äúthe requested resource does not exists‚Äù.Actually, there‚Äôs a subtlety, it could mean ‚Äúthe requested resource actually exists but it‚Äôs none of your business, you‚Äôre not allowed to access it and never will; actually, it does not exist for you‚Äù or ‚Äúthe requested resource does not exist at all‚Äù but the consumer will never know what is the true reason behind this HTTP status code.That response is the best one for the introduction‚Äôs use case, granted that users want to use this application without sharing anything with others.In that case, given that John and Emma use the application, if Emma ‚Äúhacks‚Äù the API, we will never ever want her to know that /users/{John's phone number}/calls may exists.Because they are not supposed to know it exists and even though can‚Äôt do anything about it, so better tell her that it ‚Äúdoesn‚Äôt exist‚Äù (for her).But if 404 Not Found is usually my first idea when a consumer tries to access to a /resources/1234 they shouldn‚Äôt (I admit I‚Äôm a little obsess with security and prone to not show what is not needed to be shown), there are cases where it could be interesting to let them know the target resource exists.Use 403 when consumer can do something about it    The 403 (Forbidden) status code indicates that the server understood the request but refuses to authorize it.  A server that wishes to make public why the request has been forbidden can describe that reason in the response payload (if any).        RFC 7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, section 6.5.3    Returning a 403 Forbidden signifies ‚Äúthe requested resource actually MAY exists but you cannot access it. You MAY access it by requesting adequate rights to someone, maybe an administrator for instance‚Äù.Even if that is not very realistic, let‚Äôs say that the example application/API described in the introduction allows users to share recorded conversations with others. Given John has shared his conversations with Emma but not with Tara, Emma triggering a GET /users/{John's phone number}/calls API call will get a 200 OK while Tara will get a 403 Forbidden. Tara may request John the rights to access his conversations to fix that.We have talk about 403 Forbidden and 404 Not Found, but what about the poll‚Äôs third option?Never ever use 401 (don‚Äôt be fooled by its reason)    The 401 (Unauthorized) status code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.        RFC 7235 Hypertext Transfer Protocol (HTTP/1.1): Authentication, section 3.1    As 24% of respondents to my poll, when a consumers tries to access a resource they shouldn‚Äôt access, you may be tempted to return a 401 Unauthorized instead of a 403 Forbidden.Why would you do that?Maybe because its reason phrase says Unauthorized.But that would actually be an error, don‚Äôt be fooled by that reason phrase.    There are only two hard things in Computer Science: cache invalidation and naming things.        Phil Karlton    There‚Äôs a huge problem with 401 Unauthorized, its reason phrase let think that it is tied to ‚Äúwrong authorization‚Äù while it is actually tied to ‚Äúlack of authentication‚Äù.Actually the RFC that defines it is RFC 7235 - Hypertext Transfer Protocol (HTTP/1.1): Authentication‚Ä¶ ‚ÄúAuthentication‚Äù and not ‚ÄúAuthorization‚Äù.Even the description states that this status is about ‚Äúauthentication credentials‚Äù.A 401 signifies there‚Äôs a problem with your credentials which usually are provided in an Authorization header (still wrong name, but at least it‚Äôs consistent with the reason).This status is made to signify ‚Äúyou forgot to provide an Authorization header with some credentials‚Äù or ‚Äúyour credentials provided in the Authorization header are invalid/expired‚Äù.In the API world, it basically says ‚ÄúYou can‚Äôt use the API at all, come back with a valid access token‚Äù.It‚Äôs not meant to say ‚ÄúYou can use the API but not access that resource‚Äù, that is the job of 403 Forbidden.And that is clearly stated in its description in RFC 7231 - Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content:    If authentication credentials were provided in the request, the server considers them insufficient to grant access.  The client SHOULD NOT automatically repeat the request with the same credentials.  The client MAY repeat the request with new or different credentials.  However, a request might be forbidden for reasons unrelated to the credentials.To be even more sure that 403 Forbidden is the right answer, let‚Äôs talk about Oauth 2 scopes.Indeed, dealing with resource rights access is not always, let‚Äôs say ‚Äúinternal business rule‚Äù driven (checking in users table that the identified user has the requested phone number for example).When consumers request an access token using the Oauth 2 framework (the token that goes into the not so well named Authorization header), they may request a token restricted to given elements thanks to scopes.For instance, when using the Github API, you may request access to public repo only or to user data only.What should happen when a consumer requests access to a resource without adapted scopes?Section 3.1 of RFC 6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage is quite clear:    The request requires higher privileges than provided by the access token.  The resource server SHOULD respond with the HTTP 403 (Forbidden) status code and MAY include the \"scope\" attribute with the scope necessary to access the protected resource.        insufficient_scope error    HTTP Status code is not enoughThat means two things.First 401 Unauthorized is definitely not an option in the case we are studying today.Second, HTTP status code is not enough.Indeed, 403 Forbidden could be returned because consumer lacks some scope to GET /resources/{resourceId} in general or does not comply to some business rule and cannot GET /resource/1234 (a specific id).Providing a message and maybe some structured data to explained the why of the error and how it can be solved (request access token with scope X in first case or contact some admin in second case) is mandatory.Note that, this made me realized that 403 Forbidden does not actually disclose that a resource exists, it totally depends on what is said beyond the HTTP status code.Don‚Äôt forget DX and contextRespecting HTTP and other RFCs is important to avoid surprising developers with behaviors that are against common practices, but most important, whatever the HTTP status code you‚Äôll choose to return, what matters above all is providing the response the most adapted for the context that will actually help the developer (and the consumer and even the end user) to know what is actually happening and help them solve the problem if they can.So, when consumers want to access a resource they shouldn‚Äôt, don‚Äôt return a 401 Unauthorized, you would go against the HTTP protocol.Instead, return a 404 Not Found if consumers can‚Äôt do anything about it (so from their perspective, it does not exist) and return a 403 Forbidden along with a meaningful message if they can request access."
},{
    "id": "21",
    "type": "post",
    "title": "Adopt and not assess OpenAPI linters and other thoughts reading Thoughtworks Technology Radar 24",
    "url": "