<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.0">Jekyll</generator><link href="https://apihandyman.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://apihandyman.io/" rel="alternate" type="text/html" /><updated>2022-02-09T07:48:46-06:00</updated><id>https://apihandyman.io/feed.xml</id><title type="html">API Handyman</title><subtitle>Hi! I'm Arnaud Lauret, the API Handyman and author of The Design of Web APIs. I like to share what I do, struggle with, learn, and teach while working in the API space.</subtitle><author><name>Arnaud Lauret</name></author><entry><title type="html">Choosing between raw and processed data when designing an API</title><link href="https://apihandyman.io/choosing-between-raw-and-processed-data-when-designing-an-api/" rel="alternate" type="text/html" title="Choosing between raw and processed data when designing an API" /><published>2022-02-09T00:00:00-06:00</published><updated>2022-02-09T00:00:00-06:00</updated><id>https://apihandyman.io/choosing-between-raw-and-processed-data-when-designing-an-api</id><content type="html" xml:base="https://apihandyman.io/choosing-between-raw-and-processed-data-when-designing-an-api/"><![CDATA[<p>Look how trees are represented in Piet Mondrian‚Äôs paintings shown in this post‚Äôs banner.
On the left they are represented in a figurative way, on the right totally abstracted.
This is what we‚Äôll discuss in this post, not figurative vs abstract painting, but raw vs processed data in API design.
Choosing between raw or processed data, date of birth vs age for instance, has a direct impact on developer experience but also on provider‚Äôs.
<!--more--></p>

<div class="alert alert-info"><h4 class="alert-heading">About Piet Mondrian</h4><hr />
<div class="image ">
    <figure class="figure">
        <img src="/images/choosing-between-raw-and-processed-data-when-designing-an-api/mondrian-composition.jpg" class="figure-img img-fluid" /><figcaption class="figure-caption">Composition II in Red, Blue, and Yellow, 1930</figcaption></figure>
</div>
<p><a href="https://en.wikipedia.org/wiki/Piet_Mondrian">Piet Mondrian</a>, is one of the pioneers of abstract art, but started with figurative painting.
You may know him by his compositions such as the one above.
This post banner is composed of two of his paintings.
On the left side : <a href="https://commons.wikimedia.org/wiki/File:Mondriaan_-_grazende_kalfjes.jpg">Grazing cows in a polder</a> (oil on canvas, between 1901 and 1903), on the right side: <a href="https://commons.wikimedia.org/wiki/File:Blossoming_apple_tree,_by_Piet_Mondriaan.jpg">Blossoming apple tree</a> (oil on canvas, 1912).</p>

</div>

<h1 id="a-not-so-simple-question">A not so simple question</h1>

<p>Here‚Äôs a question that I often ask when doing API design training sessions.
Let‚Äôs say we are designing an API to ‚Äúmanage Users‚Äù (not the best crystal clear need ever, but it‚Äôs just a basic example).
To fullfil some goal/job to be done, users‚Äô age must be returned.
As the underlying system stores users‚Äô date of birth, what should we do?</p>

<ul>
  <li>Return date of birth only (hence raw data)</li>
  <li>Return age only (hence processed data)</li>
  <li>Return both date of birth and age (hence raw and processed data)</li>
</ul>

<div class="alert alert-warning"><h4 class="alert-heading">Be sure of the needs!</h4><hr /><p>We will not discuss that here, but in real condition, you must be sure about WHY the age is needed and HOW it will be used. Always be careful and triple check that the need that has been identified is the right one.</p>

</div>

<h1 id="raw-data-and-terrible-consumer-side-business-logic">Raw data and (terrible) consumer side business logic</h1>

<p>We could return date of birth only.
Indeed, calculating an age, the number of years between today and a date is not that complicated.</p>

<div class="card card-code text-white bg-dark border-dark">
  
  <div class="card-header">
    <div class="row m-0">
      <div class="col align-self-center">
        <p class="m-0 title">How to NOT calculate age in JS</p>
      </div>
      <div class="col col-auto pr-0">
        <div class="btn-group" role="group" aria-label="code snippet control">
          <a role="button" class="btn btn-secondary code-copy-btn border-0 rounded-0" aria-label="copy" data-toggle="tooltip" data-placement="top" title="Copy"><img class="btn-icon" src="/images/commons/icons/copy.svg" /></a>
          
        </div>
      </div>
    </div>
  </div>
  <div class="card-body">
    <pre class="language-js line-numbers code-copy"><code class="code-block">const birthDate = Date.parse(&#39;2004-04-10&#39;);
const today = Date.now();
const differenceInMs = today - birthDate;
const differenceInYears = differenceInMs / 1000 / 3600 / 24 / 365; // 17.847940055048202
const age = Math.round(differenceInYears); // 18</code></pre>
  </div>
</div>

<p>It‚Äôs not that complicated to calculate an age, but some people can still make errors, as shown in the JS code snippet above.
If ‚Äúusers‚Äù were citizens, such error could give the right to vote to someone who is not 18 yet (we can vote at 18 in France).
That means returning raw data may lead to consumers implementing some business logic the wrong way and so can lead to more or less terrible errors.</p>

<p>Oh, you could check that consumers actually do it well ‚Ä¶
But, honestly don‚Äôt do that.
It may possibly work with one or two consumers close to you, but how will you manage that with dozens of consumers that are actual customers?
Spoiler: you won‚Äôt.</p>

<p>And even if by chance all consumers could calculate the ‚Äúage‚Äù well, what will happen if you, as the API provider, want to change that business logic?
What if, in the beginning, the ‚Äúage‚Äù was supposed to be the raw number of years as a float number and now you changed your mind and want it rounded without decimals (yes rounded because some business logic reason).
It will be complicated to tell all consumers to change that in their own code.</p>

<p>And even if consumers are willing to update their code, they may simply be unable to implement that business logic.
During some recent session, one of the attendees raised a very good point: unfortunately people die.
I never have thought of that!
If the API manages ‚Äúusers‚Äù (whatever it means) who can die, deriving age from the date of birth will not work.
And just in case it crossed your mind, don‚Äôt even dare to think returning date of death along date of birth.</p>

<p>So it seems better to return processed data such as an age than raw data such as a date of birth.
But avoiding consumers implementing business logic is not the only reason you would return processed data instead of raw data.</p>

<h1 id="sensitive-raw-data-processed-data-to-the-rescue">Sensitive raw data? Processed data to the rescue!</h1>

<p>Indeed, there‚Äôs another possible problem here if we return the date of birth to fulfill our ‚Äúage‚Äù need.
A date of birth could be considered a sensitive piece of data in some places, it even could help identify a user.</p>

<p>Just in case you‚Äôre not aware of that: privacy matters whatever you build; and APIs are no exception.
And if you don‚Äôt care, some regulations like <a href="https://en.wikipedia.org/wiki/General_Data_Protection_Regulation">GDPR</a> will force you to care about it.</p>

<p>So in such a situation, having to deal with sensitive raw data, it could be interesting to process it and make it less sensitive.
Here, returning an age instead of the date of birth would solve the problem.
Note that if it‚Äôs so sensitive, you may also have to rethink about why you actually store it, but that‚Äôs another story.</p>

<p>So again, returning the age (processed data) instead of date of birth (raw data) seems to be a good idea.</p>

<h1 id="processed--raw-data-for-more-usages">Processed + Raw data for more usages</h1>

<p>But don‚Äôt forget that your API must be usable for various use cases.
If we set aside the possible sensitivity of date of birth, maybe it could be interesting to return both values.
Indeed, date of birth could make sense for other possible use cases.
Refrain to return just what is needed for the first identified use cases.
Always expand your vision to a broader context.
How many times I‚Äôve seen web services and APIs dealing with totally dumb subsets of business concepts, missing data that are important in general whatever you do ‚Ä¶
But data that were not needed for the first use case ü§¶üèª‚Äç‚ôÇÔ∏è.</p>

<h1 id="raw-vs-process-data-impacts-developer-and-provider-experiences">Raw vs process data impacts developer and provider experiences</h1>

<p>Obviously, this raw vs processed data question is not only for age vs date of birth.
You can apply this reasoning for any piece of data.</p>

<p>Think carefully before returning raw data that will be processed on the consumer side.
Remember that an API is supposed to be ‚ÄúYOUR stuff for dummies‚Äù, do not delegate YOUR business logic to consumers.
It may make your API harder to use for consumers, they need your expertise to use it, and so that cripples developer experience.
They can do mistakes, and even if they don‚Äôt, you won‚Äôt be able to modify that consumer side business logic easily, and so that cripple your provider experience.</p>

<p>But do not do it too much either, check that how the data will be processed is actually YOUR job.
If not careful, you could end with a very specialized API working for a specific consumer.
And so this API will be hard to reuse in broader contexts by other consumers.
Again that impacts both developer and provider experience.</p>

<p>Also think about the sensitivity of the raw data you need to return.
Think about it not only fearing regulators but also for your users safety and yours, the less sensitive data, the better.
Returning processed data hiding the original raw data will avoid you many headaches, hence have a better provider experience.</p>

<p>And last but not least, it‚Äôs not because processed data is returned that you must remove the original raw data.
It could be useful for other purposes and so enhance developer experience.</p>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[Look how trees are represented in Piet Mondrian‚Äôs paintings shown in this post‚Äôs banner. On the left they are represented in a figurative way, on the right totally abstracted. This is what we‚Äôll discuss in this post, not figurative vs abstract painting, but raw vs processed data in API design. Choosing between raw or processed data, date of birth vs age for instance, has a direct impact on developer experience but also on provider‚Äôs.]]></summary></entry><entry><title type="html">7 years being the API Handyman, the age of reason?</title><link href="https://apihandyman.io/7-years-being-the-api-handyman-the-age-of-reason/" rel="alternate" type="text/html" title="7 years being the API Handyman, the age of reason?" /><published>2022-02-02T00:00:00-06:00</published><updated>2022-02-02T00:00:00-06:00</updated><id>https://apihandyman.io/7-years-being-the-api-handyman-the-age-of-reason</id><content type="html" xml:base="https://apihandyman.io/7-years-being-the-api-handyman-the-age-of-reason/"><![CDATA[<p>This time, no ‚ÄúAPI blah blah blah‚Äù, this time, it‚Äôs personal.
February 2022 marks a major landmark, I can‚Äôt believe I launched the API Handyman blog 7 years ago!
Being 7 years old is supposed to mark the ‚Äúage of reason‚Äù.
Did I reached it?
I think so, but it took me more than 7 years.
<!--more--></p>

<h1 id="failing-and-healing">Failing and healing</h1>

<p>The creation of the API Handyman blog was the starting point of a new path in my career after a few dark years.</p>

<h2 id="before-the-blog">Before the blog</h2>

<p>I started my career as a developer in 2002, then I became a software analyst (people who write specs for developers), a project manager and finally an application manager.
I followed what was quite a usual path in France at that time, but I did it without really thinking about it.
And that was a huge mistake (don‚Äôt do that at home), I realized that being a manager was definitely not for me.
But I realized it almost too late.</p>

<p>Indeed, after a few years, I was always exhausted, getting sick fairly often, not happy with most of what I had to do on my daily job.
I was actually not happy at all; and this situation had a terrible impact on my family‚Äôs life.
I didn‚Äôt realize all that consciously until that one day my body wouldn‚Äôt let me go to the office. 
Hopefully, I was in a situation where I could change that.
I actually did go to the office that one day, but to request a position change.
Hopefully my manager was also managing the architecture team and I could join it.
And so I was back to what I really liked: coding, tinkering with proof of concepts, designing systems, ‚Ä¶
I never have been so happy for years (I was as happy when I was a developer).
I was happy but not totally confident in my experience.
I was wondering if what I‚Äôve done in the past years was valuable if I want to work somewhere else.</p>

<h2 id="starting-a-blog">Starting a blog</h2>

<p>Before actually moving to the architecture team, I had to lead a major API project and became interested in the topic.
Thanks to my manager, I discovered the <a href="https://apievangelist.com">API Evangelist</a> (the guy who invented ‚ÄúAPIs blah blah blah‚Äù) and also was able to attend my very first API conference in December 2014.
At the API Days Paris conference, getting out of my cave, I saw all those stars on stage sharing their knowledge.
Listening to them, I was thinking ‚Äúthat‚Äôs amazing stuff‚Äù but also ‚Äúwait, I ran into that problem too, I solved it a bit differently‚Äù, ‚Äúhey, I did that too!‚Äù‚Ä¶
Suddenly I realized that many of those ‚Äústars‚Äù were normal people sharing their stories.</p>

<p>All that made me realized that I actually did not lost my time but learned valuable and interesting things in the past years (sometimes by trial and errors) .
During all my career, I have been working on connecting pieces of software together.
I worked on distributed (and heterogenous) systems, file transfers, SOA (Service Oriented Architecture), IVR (Interactive Voice Response), web, mobile and what we call now (web) APIs.
I realized that sharing my stories could help others.
And as a few months earlier, I had given a hand to my wife to migrate her blog from some platform to a self hosted Wordpress, it did not take me long to think about starting my own blog to talk about APIs.</p>

<p>But why did I created the ‚ÄúAPI Handyman Blog‚Äù and not ‚ÄúArnaud Lauret‚Äôs Blog‚Äù?
I was quite intimidated to publicly ‚Äúspeak‚Äù (actually write) about APIs, so hiding behind a nickname was convenient.
I wanted a funny name that would make people know that this blog was about APIs.
So I searched an ‚ÄúAPI <em>whatever</em>‚Äù name and came with ‚ÄúAPI Handyman‚Äù because it perfectly reflected my vision of what I do with software and APIs.</p>

<p>It took me weeks, especially to write my very first post, but at last on the 7th February 2015 the API Handyman blog was live with my very first post ‚Äú<a href="/why-you-must-design-your-private-api-in-english/">Why you must design your private API in english</a>‚Äù.
The very first comment (yeah, there were comments at that time), came from the API Evangelist himself, I was totally crazy.</p>

<p>Writing about APIs hoping helping others, actually helped me more than I would have imagined.
I met amazing people, make new friends, talked at conferences, live tweeted dozens of conference sessions, wrote a book, got two wonderful jobs.
But more than that, I became API Handyman.</p>

<h1 id="becoming-the-api-handyman">Becoming the API Handyman</h1>

<p>Slowly, but surely, I became ‚ÄúAPI Handyman‚Äù (or he became me?) because the content I create and my work feed each other, but also because I finally chose to wear my API Handyman costume everyday to become a confident API expert.</p>

<h2 id="creating-content-is-hard-but-worth-the-cost">Creating content is hard but worth the cost</h2>

<p>Creating content was hard in the ‚Äúbeginning‚Äù, it actually took me years to become more comfortable doing it.
In the beginning writing a post could take me weeks.
I spent more than 2 years on my book The Design of Web APIs.
Creating my conference session was also hard, I remember finishing my first keynote preparation at 3pm, a few hours before presenting.
But session after session it became easier.</p>

<p>Was it worth the cost?
Totally.
All this hard work helped me getting better at explaining things, articulating ideas, and telling stories.
It also helped me to learn more about many topics.
Even when I want to talk about something I do everyday, I often realize that I need to think more about it or do researches in order to actually be able to explain it in an easy to understand way.
That definitely help me getting better at doing my daily job ‚Äúhelping people to understand and to create APIs‚Äù.</p>

<p>I made all this work easier by doing it only when I wanted to and by trying to keep it as fun as possible.
Working on the form, using pop-culture reference, and creating high quality visuals really helps me.</p>

<h2 id="becoming-a-confident-api-expert">Becoming a confident API expert</h2>

<p>Speaking of pop-culture reference, I created T-shirts (actually, I asked my wife to draw them) such as the ‚ÄúMasters of the APIverse‚Äù, ‚ÄúRespect my API Style Guide‚Äù or ‚ÄúAPI Titans Go!‚Äù to wear them when going at conferences, it‚Äôs my API Handyman costume (no, I don‚Äôt wear underwear over pants like Superman).
When I became an API architect for Natixis, I decided to wear them everyday, whatever I was doing, whoever I was suppose to meet.
I remember being lost in a building and encountering someone I‚Äôve never met who told me ‚ÄúI think we have a meeting together‚Äù.
Those t-shirts helped me breaking the ice in some meetings.</p>

<p>They helped me in being more confident, but didn‚Äôt do all the work.
Working day after day with dozens of different teams, doing hundred of API design reviews/workshops/training while being more and more the API Handyman, I at last accepted myself as an expert (Oh, <a href="/and-what-if-im-wrong-overcoming-fears-and-doubts-while-designing-apis/">I still have the impostor syndrome, but I learned to live with it</a>).
I hope not to be an arrogant one.
I‚Äôm not here to yell at people, but listen to them and help them (if they want to be helped) in their context, not providing out of the blue inapplicable solutions, always willing to learn new things.
I‚Äôm capable to say ‚ÄúI don‚Äôt understand‚Äù, ‚ÄúI don‚Äôt know‚Äù and ask ‚Äúsilly‚Äù questions (there‚Äôs actually no silly questions).</p>

<h1 id="whats-next">What‚Äôs next</h1>

<p>Being the API Handyman was quite fun and exciting so far, especially, the last 4 years at Natixis which were totally amazing.
But my Natixis adventure is over because I couldn‚Äôt refuse an even more amazing offer.
I just joined Postman and will go on being the API Handyman there (you‚Äôll be able to read more about this on Postman‚Äôs blog).</p>

<p>Since I started the API Handyman blog, I rationally analyzed and accepted 2 wonderful job offers, I became and accepted myself as an expert taking advantage of my past and willing to learn.
So, yes, professionally speaking, I think I have reached the age of reason, both as API Handyman and Arnaud Lauret.</p>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[This time, no ‚ÄúAPI blah blah blah‚Äù, this time, it‚Äôs personal. February 2022 marks a major landmark, I can‚Äôt believe I launched the API Handyman blog 7 years ago! Being 7 years old is supposed to mark the ‚Äúage of reason‚Äù. Did I reached it? I think so, but it took me more than 7 years.]]></summary></entry><entry><title type="html">What to consider when building an API sandbox</title><link href="https://apihandyman.io/what-to-consider-when-building-an-api-sandbox/" rel="alternate" type="text/html" title="What to consider when building an API sandbox" /><published>2022-01-26T00:00:00-06:00</published><updated>2022-01-26T00:00:00-06:00</updated><id>https://apihandyman.io/what-to-consider-when-building-an-api-sandbox</id><content type="html" xml:base="https://apihandyman.io/what-to-consider-when-building-an-api-sandbox/"><![CDATA[<p>Used through the ‚Äútry it‚Äù feature of an API‚Äôs documentation or directly called by a consumer application, an API sandbox is a great way to let developers play with an API and learn how it works without giving them access to the actual production environment.
But what is an ‚ÄúAPI sandbox‚Äù actually?
Is it just a mock?
It can be that ‚Ä¶ or far more than that.
Let‚Äôs see what could be the features of an API sandbox.
<!--more-->
This post is a sequel to my previous post ‚Äú<a href="/a-few-concerns-to-be-aware-of-when-adding-try-it-feature-to-api-documentation/">A few concerns to be aware of when adding try it feature to API documentation</a>‚Äù.</p>

<h1 id="what-is-an-api-sandbox">What is an API sandbox</h1>

<p>An API sandbox is an application or set of applications that simulates an actual API.
Quite often tied to the ‚Äútry it‚Äù feature, which allows to make API calls from an API‚Äôs documentation, it could also reveal to be quite useful directly called from code created by developers who subscribed to use the API.</p>

<p>Regardless of how it is used, the main purpose of a sandbox is usually to be the playground that help people learn how the API works.
In an ideal world, consumers should be able to write code against the API sandbox and then be able to switch their API calls from the sandboxed version to the real version without any modification (besides configuration).</p>

<p>Usually, the first thought regarding a sandbox is that, if the real API provides a <code>GET /this</code> or a <code>POST /that</code>, its sandbox counterpart will propose them too, mimicking their behavior in a more or less accurate fashion.
That could make think a sandbox is ‚Äújust‚Äù a basic mock, which is not always the case.</p>

<h1 id="what-are-the-features-of-an-api-sandbox">What are the features of an API sandbox</h1>

<p>If an API sandbox is supposed to mimic what the real API does, let‚Äôs see what happen when consumers interact with a real ‚Äútask list‚Äù API:</p>

<ul>
  <li>Consumers calling the API to ‚Äúsearch tasks‚Äù without an access token get an error.</li>
  <li>Obtaining an access token can be done in a machine to machine way or involving an end user authentication, depending on what they want to do.</li>
  <li>Consumers calling the API with an access token tied to wrong scopes get an error. For instance if the access token has not the scope ‚Äúwrite access‚Äù, consumers are not allowed to ‚Äúcreate a task‚Äù.</li>
  <li>When calling the API (with an access token), they get an accurate response which is consistent with their request, either for a success or failure. For instance, if they ‚Äúsearch tasks‚Äù, they get a list of tasks matching their search parameters. If they ‚Äúcreate a task‚Äù, providing a user name and a description, in return they get the input data plus a server generated id. If they forgot to provide the username, or provide a non existing user, or provide a user for which they are not allowed to create a task, they get an error telling them so.</li>
  <li>For a subsequent request, they get a response which is consistent with previous calls. Like seeing their created tasks in the response of ‚Äúsearch tasks‚Äù or being able to retrieve the created task based on the returned id (with ‚Äúread task‚Äù).</li>
  <li>Depending on consumer and/or end user profile, consumers may be allowed to do or not to do specific API calls, like reading or deleting a specific task created by other consumer for instance</li>
  <li>And finally an API call or an internal process running without consumer interaction may trigger something that impacts the consumers or the end users outside of the API. For instance, an SMS or an email could be sent to the user identified in the created task or a webhook may be called.</li>
</ul>

<p>But a sandbox shouldn‚Äôt only simulate the real API, it should also provide any ‚Äúmeta-feature‚Äù that will help people learn how to use it.
And last but not least, the sandbox should be easily ‚Äúintegrable‚Äù in the API documentation.</p>

<p>If we sum those 3 dimensions, that mean an API sandbox is supposed to propose the following features:</p>

<ul>
  <li>Expose the same interface contract as the real API</li>
  <li>Provide useful data</li>
  <li>Simulate implementation and dependencies behaviors</li>
  <li>Save and restore data</li>
  <li>Simulate high level security</li>
  <li>Simulate non API visible dependencies</li>
  <li>Be API first</li>
</ul>

<h2 id="expose-the-same-interface-contract-as-the-real-api">Expose the same interface contract as the real API</h2>

<p>Using the API, or a fake version of it in this case, really helps to learn how an API work and what you can do with it.
The most minimal API sandbox must expose the same interface contract as the original API.
It must provide all of the operations described in the interface contract.
All those operations, such as <code>GET /this</code> and <code>POST /that</code>, must respect the paths, parameters, body, data models, HTTP status codes, ‚Ä¶ described in the original interface contract.
And the contract must be respected even in case of error (which is often neglected).
Working at this level is usually made working with an API specification such as the OpenAPI Specification.</p>

<p>But ‚Äújust‚Äù simulating the interface contract is usually not enough for a sandbox.</p>

<h2 id="provide-useful-data">Provide useful data</h2>

<p>It‚Äôs quite simple to simulate an interface contract based on a specification document using randomly generated and inconsistent data for each call.
But that‚Äôs not really useful to learn how the API works.
Indeed, if I ‚Äúsearch tasks‚Äù, I would prefer to get a meaningful <code>description</code> such as <code>write a blog post</code> instead of <code>lorem ipsum</code>, or worse <code>azljkiqjnlkjpoi</code>, for each element in the list.
Also, once I got my list of tasks, I would be very happy to pick the <code>id</code> of one of them,  such as <code>123</code>, to do a <code>GET /tasks/123</code> (‚Äúread task‚Äù) and get data which is consistent with my previous call.</p>

<p>On top of that, providing useful global data sets allowing to cover various use cases is important.
In our ‚Äútask list‚Äù case, it could be having tasks with all possible types and states or tasks created by various users.
The more real the data, the better the experience and so the learning.
But more important, the less risk of variations between code running against sandbox and production.</p>

<p>But, as I often say, an API is not only about data, an API proposes a service; there‚Äôs added value logic inside an API.
And just working at data level is sometimes not enough to simulate that.</p>

<h2 id="simulate-implementation-and-dependencies-behaviors">Simulate implementation and dependencies behaviors</h2>

<p>The implementation of an API holds 3 types of logic a sandbox must try to reproduce as closely to reality as possible:</p>

<ul>
  <li>Surface controls</li>
  <li>Application level security</li>
  <li>Business rules</li>
</ul>

<p>Surface controls are all the parameters/properties presence, format and value checks.
Is the mandatory <code>username</code> present? Is the task <code>type</code> value in allowed values list?
Most of the time, those controls can be directly tied to the interface contract description.
But due to limitations or lack of knowledge of the specification used (do you know that you can specify a regex pattern for a string property in OpenAPI for instance), that sometimes requires more work.</p>

<p>Application level security are those controls an implementation will do to ensure that consumer and possible end user don‚Äôt see or do  more than they should.
They are based on access token information (consumer, scopes, end user, roles) and business data.
For instance, ‚Äúis this user allowed to modify this specific task?‚Äù or ‚Äúwhat are the specific tasks this user can see?‚Äù.</p>

<p>And last but not least, the business rules.
They are the heart of the implementation: what is done to fullfil what the API is supposed to do.
These are the controls and actions made by the implementation based on business logic and data.
For instance, ‚ÄúDoes this user for who I‚Äôm supposed to create a tasks exists?‚Äù, ‚ÄúI read the task for this id‚Äù, ‚Äúthe time of a tasks is the sum of time of all subtask‚Äù or ‚Äúeverything is OK, I insert a task in this table of the database‚Äù.</p>

<p>Note that an implementation can rely on dependencies.
Depending on your context you may or may not have to work on simulating what is happening in those dependencies.
If our simple ‚Äútask list‚Äù API use case implementation is composed of a basic whatever-language monolithic server application and a database, no dependency problem.
But what it relies on a ‚Äúuser‚Äù component to check if a user exists for instance?
Do we need to simulate that component?
And how?
Do we create a single sandbox or one per component?</p>

<p>Also what if this component exposes a ‚Äúuser‚Äù API that can be used by the same consumers?
Should the ‚Äútask list‚Äù sandbox do what is necessary to propagate data to the ‚Äúuser‚Äù sandbox to have a consistent <code>tasksCount</code> property while calling ‚Äúread user‚Äù?</p>

<p>Whatever the complexity of the implementation algorithms and architecture, data needs to be saved in the end more often than not in order to provide a realistic and consistent behavior.</p>

<h2 id="save-protect-and-restore-data">Save, protect and restore data</h2>

<p>Being able to retrieve a previously created or modified task means that the corresponding data have been saved.
If we go on along that line, data can be modified or deleted.
And if the data can be created, modified, or deleted, it may mean in the end that the data will be, not corrupted (the implementation is supposed to prevent that), but seriously messed up.
The quite useful task list containing all types and statuses combinations could not be there anymore for instance.
So maybe some data should be protected against modification and deletion, but that could possibly make the API less realistic.
Another option could be to provide a way to restore the sandbox into an initial clean state when needed.</p>

<p>If data can be modified, in a broad sense, how long should it be kept?
Forever or only for a given amount of time?
Maybe data should be restored automatically to its initial state at some point.</p>

<p>Also, allowing to modify sandbox data for whatever reason should be done not forgetting that, at a given moment, various consumers may work with the sandbox independently.
They should be able to do that without being bothered by what others do (and reverse).
Being able to actually separate who is doing what could be interesting in order to prevent problems, and working on security could help on that topic (among other things).</p>

<h2 id="simulate-high-level-security">Simulate high level security</h2>

<p>What I call ‚Äúhigh level security‚Äù concerns what is usually handled by an API gateway and an identity provider.
That means deciding which consumer can access which API (even which operation inside an API), obtaining an access token to make API calls with or without end user authentication, and control those access tokens.
For instance, a consumer may be allowed to ‚Äúread task‚Äù but not to ‚Äúmodify task‚Äù.
Note that, it does not mean that this consumer may read all tasks, it will be up to the implementation to check if a specific consumer is allowed to read a specific task (see Simulate implementation and dependencies behaviors above).</p>

<p>Simulating the implementation is already quite a burden, so why bother adding such complexity to a sandbox?</p>

<p>Even when your API uses standard security, such as Oauth 2 or OpenId connect, don‚Äôt take for granted that everyone knows all possible ‚Äúgive me an API access token‚Äù dances.
There always will be beginners who never have used them before, and even those who have encountered such way of securing APIs may need a refresh.
So, having an API sandbox allowing to to test how to get an access token is welcomed.</p>

<p>Also, in order to test various use cases, consumers may need an access token attached to specific scopes and possibly specific end user.
Being able to get ready to use or taylor made access token would be of great help.</p>

<p>And finally, just being able to differentiate which consumer makes an API call to the sandbox may help regarding the partitioning of saved/restored data.</p>

<h2 id="simulate-non-api-visible-dependencies">Simulate non API visible dependencies</h2>

<p>Depending on the kind of service provided, consumers may interact with the system exposing it in other ways than calling the API.
For instance, what if the user identified in a task is notified by an email or an SMS upon its creation?
What if, when task is closed (however it is done), the consumer which has created it is notified through a webhook call?
Providing to consumers a kind of administration console logging what should happen outside of the API would help to show all that.</p>

<p>All those features being implemented would make a terrific sandbox, but it‚Äôs not over yet, there‚Äôs one last feature to think about.</p>

<h2 id="be-api-first">Be API First</h2>

<p>Some of the previous features imply the consumers interact with the sandbox for doing other things than what the original API and surrounding elements are supposed to do:</p>

<ul>
  <li>Knowing which are the available use cases (useful data)</li>
  <li>Getting a ready to use access token, which may require to know who are the predefined users (high level security)</li>
  <li>Knowing if something happened outside of the API (non API visible dependencies)</li>
</ul>

<p>Being API first and providing one or more APIs to deal with these ‚Äúmeta-functions‚Äù is a must have for such an advanced sandbox.
Such ‚Äúsandbox API‚Äù could be used to build great API documentation (always in sync seamless ‚Äútry it‚Äù providing everything people need, like the possible use cases for an operation).
And why not let it be ‚Äúconsumed by consumers‚Äù too (or at least other apps developed by their developers), if they need to reset their sandbox state they would probably be happy to do that programmatically.</p>

<h1 id="so-much-work">So much work?</h1>

<p>As you can see, providing an accurate and complete sandbox may require to care about many features.
Hopefully, you don‚Äôt always need such level of accuracy.
In a next post, we‚Äôll see various tools and architecture patterns that could help you achieve the right level of API sandbox.</p>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[Used through the ‚Äútry it‚Äù feature of an API‚Äôs documentation or directly called by a consumer application, an API sandbox is a great way to let developers play with an API and learn how it works without giving them access to the actual production environment. But what is an ‚ÄúAPI sandbox‚Äù actually? Is it just a mock? It can be that ‚Ä¶ or far more than that. Let‚Äôs see what could be the features of an API sandbox.]]></summary></entry><entry><title type="html">A few concerns to be aware of when adding try it feature to API documentation</title><link href="https://apihandyman.io/a-few-concerns-to-be-aware-of-when-adding-try-it-feature-to-api-documentation/" rel="alternate" type="text/html" title="A few concerns to be aware of when adding try it feature to API documentation" /><published>2022-01-19T00:00:00-06:00</published><updated>2022-01-19T00:00:00-06:00</updated><id>https://apihandyman.io/a-few-concerns-to-be-aware-of-when-adding-try-it-feature-to-api-documentation</id><content type="html" xml:base="https://apihandyman.io/a-few-concerns-to-be-aware-of-when-adding-try-it-feature-to-api-documentation/"><![CDATA[<p>‚ÄúThat‚Äôs neat!
The developer portal/api documentation solution we chose comes with a try it feature.
Everything is out of the box, we‚Äôll have absolutely nothing to do to allow people test our APIs.‚Äù
‚Ä¶ If only that was true.
Unfortunately, there are a few concerns to be aware of to actually propose a try it feature.<br />
<!--more--></p>

<h1 id="what-is-a-try-it">What is a ‚Äútry it‚Äù</h1>

<p>When browsing an API documentation, most usually when looking at the reference documentation (the one describing all <code>GET /this</code> and <code>POST /that</code>), you‚Äôll see a ‚Äútry it‚Äù or ‚Äúsend request‚Äù button.
Clicking on it, you‚Äôll get a form allowing to provide data (query parameters or request body) and then send an API request.
That‚Äôs pretty useful to learn how an API works without having to write a single line of code.
That greatly contributes in creating a good user experience, either users are developers who will create applications consuming your APIs, but also decision makers who are evaluating them.</p>

<h1 id="choosing-an-api-to-call">Choosing an API to call</h1>

<p>The first question you must explore when working on adding a try it feature to your API documentation is ‚Äúwho you gonna call?‚Äù.
Not Ghostbusters obviously.
The try it feature can trigger more or less real API call.</p>

<p>Indeed, There could be no actual API call, the website just showing fake data.
It can also make actual API call but not to the real API.
A try it may call a sandbox environment that reproduces or simulates the production environment.
And last but not least, it could trigger a call to the real production API.</p>

<p>You‚Äôre under no obligation to apply only one of those solutions, the API that will be called may depend on the user profile.
For instance, if the user is not connected maybe they can only get the local fake data and if they are connected gain access to the sandbox environment.
You may also let user choose themselves, once connected, they could choose between sandbox and production environment.</p>

<h1 id="managing-security">Managing security</h1>

<p>It‚Äôs rare to provide unsecured APIs, even sandboxed ones.
So, when providing a try it feature, you‚Äôll have to find a way to provide a relevant access token before triggering the API call.
Obviously, letting end user manage that all by hand would be a terrible idea.
Better find a way to make that as seamless as possible, if possible without any user‚Äôs help.</p>

<h1 id="providing-samples">Providing samples</h1>

<p>In order to provide an even better end user experience, it would be interesting to provide ready to use data.
For instance, if I can try <code>GET /accounts/{accountNumber}</code>, I would be very happy having a drop list with accounts in various situations.
If can try a <code>POST /accounts</code>, a pre-filled body could be great, and a list of pre-filled body even more great. 
Also when dealing with security, providing a way to choose some different user profiles, like ‚Äúuser with a single bank account‚Äù or ‚Äúuser with joint bank account and 2 savings‚Äù can be quite interesting.
The chosen profile conditioning all requests done through the try it.
Note that I must also be able to send my own request without using sample data.</p>

<h1 id="embedding-try-it">Embedding try it</h1>

<p>I said in the beginning of this post that the try it feature is often seen in the reference documentation, but it can be elsewhere.
It‚Äôs especially interesting to put some try it forms in the ‚Äúrecipe documentation‚Äù, the tutorials explaining how API operations can be used together to achieve some use cases.
Being able to put a try it form anywhere, a little bit √† la jupyter notebook, will allow to easily create awesome documentation that users will love.
And being able to do an API call from the home page would be terrific!</p>

<h1 id="try-it-and-beyond">Try it and beyond</h1>

<p>I hope you‚Äôll find this post useful when you‚Äôll think about adding a ‚Äútry it‚Äù to your API documentation.
Note that people may need to try your API outside of its documentation, that‚Äôs why a working on a good sandbox is important.
But we‚Äôll talk more about that in another post.</p>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[‚ÄúThat‚Äôs neat! The developer portal/api documentation solution we chose comes with a try it feature. Everything is out of the box, we‚Äôll have absolutely nothing to do to allow people test our APIs.‚Äù ‚Ä¶ If only that was true. Unfortunately, there are a few concerns to be aware of to actually propose a try it feature.]]></summary></entry><entry><title type="html">Nobody cares about API design guidelines</title><link href="https://apihandyman.io/nobody-cares-about-api-design-guidelines/" rel="alternate" type="text/html" title="Nobody cares about API design guidelines" /><published>2022-01-12T00:00:00-06:00</published><updated>2022-01-12T00:00:00-06:00</updated><id>https://apihandyman.io/nobody-cares-about-api-design-guidelines</id><content type="html" xml:base="https://apihandyman.io/nobody-cares-about-api-design-guidelines/"><![CDATA[<p>‚ÄúDid you read our API design guidelines? Yes we did! ‚Ä¶ Sorry, but I don‚Äôt think so‚Äù.
Let‚Äôs be honest, besides those who write them, nobody cares about API design guidelines.
Some don‚Äôt read them, some don‚Äôt agree with them.
Should we punish the offenders?
Though it is sometimes tempting, no.
Should we get rid of API design guidelines?
No, we can‚Äôt.
But how can we make people care about it?
<!--more--></p>

<h1 id="why-not-getting-rid-of-guidelines">Why not getting rid of guidelines?</h1>

<p>No, we can‚Äôt get rid of our API design guidelines because ‚Äúnobody‚Äù reads them.
Actually, they‚Äôre useful and a few people read them.</p>

<p>As an API design reviewer, I constantly have to refer to them during API design review.
I refer to them to support what I say and avoid endless discussions.
Guidelines are our tables of the law and we must follow them.
I don‚Äôt want to lose my time discussing for the 100th time how should be named the property holding the list in the response of <code>get /customers</code>.
I also use them to find solutions to some design questions and to refresh my memories.
Guidelines makes reviewer more comfortable; with them, they don‚Äôt just give an opinion, they‚Äôre backed by written rules.</p>

<p>Also, without guidelines, I could slightly change a design pattern without noticing it.
And I‚Äôm not the only reviewer, a single written source of truth ensures that multiple reviewers are consistent (at least for what concerns the stylistic perspective).
Guidelines are there to ensure consistency, that‚Äôs their primary objective.
It‚Äôs a major concern when you want to provide the best possible developer experience.
This can‚Äôt be achieve without them.</p>

<p>So we can‚Äôt get rid of them, maybe they need to be tweaked?</p>

<h1 id="simplify-and-enhance-guidelines">Simplify and enhance guidelines</h1>

<p>‚ÄúBe honest, you didn‚Äôt read our company API design guidelines.
Why denying it, I‚Äôm reviewing your API and I can see you didn‚Äôt read them seriously.
Indeed, rule #245 about over-resilient resource has not been applied.‚Äù</p>

<p>Sometimes people will try to read guidelines but they can be too complex for mere mortals.
It could be because they are written in some ‚Äútoo smart and complex expert that shows off‚Äù style.
If people need 3 PhDs in computer science to understand them, those guidelines are totally wrong, change them to make them understandable by anyone (like you‚Äôre supposed to do when you design APIs).
It could also be because they go against common practices, what everybody does in the outside world.
If that is so, those guidelines are totally wrong, change them to be consistent with the rest of the world (like you‚Äôre supposed to do when designing APIs).</p>

<p>Sometimes, guidelines are good but not easily actionable.
Indeed, guidelines composed of hundreds of rules are a nightmare to use, even when those rules are perfectly understandable by anyone.
Providing actionable recipes like ‚Äúhow to search something‚Äù, ‚Äúhow to manage sensitive data‚Äù, or ‚Äúhow to deal with long operations‚Äù is a must have.
Each recipe included everything, every single rule that must be apply explain in a user friendly way: when and why using this recipe, HTTP method to use, path design, inputs, outputs, how to handle errors.
That actually helps to ensure that guidelines are realistic, if any simple recipe is a nightmare to describe, maybe your rules are too complex.</p>

<h1 id="foster-agreement">Foster agreement</h1>

<p>Some people don‚Äôt agree with guidelines.
Sometimes they‚Äôre just assholes, sometimes they just need explanation about why rule #245 is that way, and sometimes they‚Äôre actual good people caring about API design.</p>

<p>For real stubborn/toxic/full of themselves assholes, unfortunately, I don‚Äôt know if anything can be done.
Fortunately, I don‚Äôt have met much of them and I always was in a position where I could say ‚Äúok, let‚Äôs not work together then, there are plenty of other people who want to work with me, but if you change your mind, the door is still open‚Äù.</p>

<p>But sometimes, people you could consider as ‚Äúassholes‚Äù because they don‚Äôt agree with you are people who just don‚Äôt get it; they need some explanations.
Once they get it, they‚Äôre convinced.
That‚Äôs why it‚Äôs really important to explain why each rule exists in your guidelines, if there‚Äôs no reason ‚Ä¶ maybe it shouldn‚Äôt exist.</p>

<p>And last but not least there are a few people who are really good at designing APIs and care about it.
If they don‚Äôt agree with you, maybe you should listen to them.
Don‚Äôt be an asshole yourself.
You probably should include them in the loop of your guidelines creation/evolution.
Actually, include more people in the loop brings various sensibility, various experience and this is good for your guidelines.</p>

<h1 id="provide-more-than-guidelines">Provide more than guidelines</h1>

<p>The ‚Äúguidelines‚Äù (wiki, website) are never enough.
Even the best ones.
You‚Äôll need to make them available in other more actionable forms.</p>

<h2 id="openapi-specification-templates-and-fragments">OpenAPI Specification templates and fragments</h2>

<p>You can provide ready to use specification templates and reusable fragments.
Nothing better than a complete OpenAPI file containing everything you need to ‚Äúsearch something‚Äù, you can take advantage of descriptions to explain your guidelines and point to them.
Designers just have to adapt that template to their use cases.
It‚Äôs also fairly common to have data structures, parameters, headers that are always the same.
Why not define them once and for all in reusable OpenAPI spec fragments that can be referenced.</p>

<h2 id="linter">Linter</h2>

<p>Even with templates, people can make mistakes.
You‚Äôll need to provide a way to lint API descriptions in order to help designers fix most stylistic problems themselves (and learn how your guidelines work in the making).
You can use <a href="/toolbox/spectral/">Stoplight Spectral</a> to do so.
Warning: having a linter will never, ever, replace API design reviews.
A linter won‚Äôt tell you if an API is the good ones, if a name is the good one, if using this design patterns was a good idea.</p>

<h1 id="make-everybody-love-your-guidelines">Make everybody love your guidelines</h1>

<p>So, if you want people to care about API design guidelines:</p>

<ul>
  <li>Keep them simple to understand and to use</li>
  <li>Explain and listen to foster agreement</li>
  <li>Make their use seamless by providing helpers and tools</li>
</ul>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[‚ÄúDid you read our API design guidelines? Yes we did! ‚Ä¶ Sorry, but I don‚Äôt think so‚Äù. Let‚Äôs be honest, besides those who write them, nobody cares about API design guidelines. Some don‚Äôt read them, some don‚Äôt agree with them. Should we punish the offenders? Though it is sometimes tempting, no. Should we get rid of API design guidelines? No, we can‚Äôt. But how can we make people care about it?]]></summary></entry><entry><title type="html">API design and architecture lessons from a frying pan</title><link href="https://apihandyman.io/api-design-and-architecture-lessons-from-a-frying-pan/" rel="alternate" type="text/html" title="API design and architecture lessons from a frying pan" /><published>2022-01-05T00:00:00-06:00</published><updated>2022-01-05T00:00:00-06:00</updated><id>https://apihandyman.io/api-design-and-architecture-lessons-from-a-frying-pan</id><content type="html" xml:base="https://apihandyman.io/api-design-and-architecture-lessons-from-a-frying-pan/"><![CDATA[<p>In the kitchen, I‚Äôm the dishwasher.
And lately, washing our new frying pans has got me thinking about design and API architecture issues.
This post is dedicated to the person who complained that my book contained too many analogies.
Sorry, but no matter what I do, read, look at, listen to, I‚Äôm always trying to see if I can make connections to APIs.
And housework is no exception.
<!--more--></p>

<p>Washing dishes is a household task that I actually enjoy.
It allows me to satisfy my compulsive urge to sort things, in this case cutlery, glasses, plates or dishes.
This may be one of the characteristics of my mind that make me rather good at doing API design reviews.
It also allows me to listen to music.
But also and most importantly, it allows me to cogitate.</p>

<h1 id="pans">Pans</h1>

<p>For some time now, we have had new frying pans.
They have everything that makes a good pan, a thick bottom, a body covered with enamel (a nice change from Teflon), and a solid handle with a good grip. They are even oven safe.
In use, nothing to complain about.
When washing, it‚Äôs a different story.
If cleaning the enamelled steel is not a problem, cleaning the outside edge is a pain.</p>

<div class="image ">
    <figure class="figure">
        <img src="/images/api-design-and-architecture-lessons-from-a-frying-pan/pan.jpg" class="figure-img img-fluid" /></figure>
</div>

<p>And yes, when you use a frying pan, you also dirty the outside edge, there are often splashes or drips, especially on the handle.
And on these pans, cleaning the 2 millimeter gap between the handle and the edge of the pan is quite complicated with a sponge.
In the end, we manage to do it with a small brush, but we could do without this difficulty (relative, of course).
A handle placed a little lower or stuck to the edge of the pan, or simply no edge would have avoided this inconvenience.
The fact that an object, kitchen utensil or other, is an eyesore to clean is unfortunately quite common.
It seems that the designers of these products forget that in addition to using them for what they were designed for, they need to be cleaned.</p>

<h1 id="apis">APIs</h1>

<p>‚ÄúBut what does this have to do with APIs?‚Äù you might ask.
There is not one but (at least) two analogies here.</p>

<p>The first one is that when you design an API, you have to think about all the profiles (or users) that will use it, otherwise you might forget to include important features.
If we stop at uses, we will think about ‚Äúcooking‚Äù but not necessarily ‚Äúwashing the dishes‚Äù.
Going through the prism of users reduces the risk of forgetting features.
Here, the first users of a frying pan that we think of are necessarily the cooks.
But, in a kitchen, there are also pearl divers (the persons who wash dishes) who will also ‚Äúuse‚Äù the pans but in very different ways.</p>

<p>The other way to look at it would be to think of the users of the API vs. the maintainers of the system exposing the API.
Cooks can be thought of as the users of a pan and pearl divers as the maintainers of the system.
While it is now pretty much accepted that the user experience of APIs is important (although there is still a way to go for private APIs), I have too often seen convoluted and complex implementations that make the life of maintainers impossible.
Too many modules, too many different technologies, unnecessarily sharp technologies, non mastered technologies, maintenance procedures not completely automated, ‚Ä¶
In short, we forget the experience of the system maintainers.
Icing on the cake, in addition to bothering them, such systems are more complex to evolve and more fragile.</p>

<p>So the next time you design an API and its underlying architecture, think about washing frying pans and think about all the users.</p>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[In the kitchen, I‚Äôm the dishwasher. And lately, washing our new frying pans has got me thinking about design and API architecture issues. This post is dedicated to the person who complained that my book contained too many analogies. Sorry, but no matter what I do, read, look at, listen to, I‚Äôm always trying to see if I can make connections to APIs. And housework is no exception.]]></summary></entry><entry><title type="html">How to choose ids and codes to build user-friendly and interoperable APIs</title><link href="https://apihandyman.io/how-to-choose-ids-and-codes-to-build-userfriendly-and-interoperable-apis/" rel="alternate" type="text/html" title="How to choose ids and codes to build user-friendly and interoperable APIs" /><published>2021-12-29T00:00:00-06:00</published><updated>2021-12-29T00:00:00-06:00</updated><id>https://apihandyman.io/how-to-choose-ids-and-codes-to-build-userfriendly-and-interoperable-apis</id><content type="html" xml:base="https://apihandyman.io/how-to-choose-ids-and-codes-to-build-userfriendly-and-interoperable-apis/"><![CDATA[<p>As an API designer, why should you care about the value of a <code>productId</code>, a <code>countryCode</code>, or an error <code>code</code>?
Because wisely choosing the value of such (in a broad sense) ‚Äúidentifiers‚Äù greatly participates in the making of a user friendly API; but most importantly an interoperable one.
<!--more--></p>

<p>The following ‚ÄúScientific quadrant‚Äù (inspired by <a href="https://www.gartner.com/en/research/methodologies/magic-quadrants-research">Gartner‚Äôs Magic Quadrant</a>), shows a few examples of those identifiers sorted along 2 axes, interoperability and human-readability.
Let‚Äôs analyse those 2 dimensions and those examples more closely to see how to choose ‚Äúidentifiers‚Äù.</p>

<div class="image ">
    <figure class="figure">
        <img src="/images/how-to-choose-ids-and-codes-to-build-userfriendly-and-interoperable-apis/scientific-quadrant-for-identifiers.jpg" class="figure-img img-fluid" /></figure>
</div>

<h1 id="interoperability">Interoperability</h1>

<p>Interoperability is the ability of software to exchange and make use of information.
For instance, switching from file exchange to exposing web APIs is a first (great) step in improving the interoperability of a system.
That actually improves how other systems can exchange information with yours.</p>

<p>But does exposing APIs magically makes using information easier for consumers?
It highly depends on the actual data exposed (output) or expected (input) through it, and especially its ids and codes.</p>

<h2 id="internal-vs-standard">Internal vs standard</h2>

<p>For instance, using a <code>123</code> purely internal code to represent a country such as ‚ÄúFrance‚Äù is far less interoperable than using <code>FRA</code>, the widely adopted ISO3166 country alpha-3 code standard.
If <code>GET /authors</code> returns a list of authors with their name and country for instance, it will be fairly easy for any system to interpret a standard <code>FRA</code> country code than an obscure <code>123</code>.</p>

<p>Indeed, enabling the interpretation by consumers of such a purely internal identifier may require:</p>

<ul>
  <li>Providing extra documentation, like a (terrible) table of custom country codes and names (seriously don‚Äôt do that)</li>
  <li>Or adding an extra operation to the API, like a <code>GET /countries</code> returning all country codes and names or a more specific <code>GET /countries/{countryId}</code>  (that‚Äôs less terrible)</li>
  <li>Or adding extra data, like returning author‚Äôs country name along with the code (that make the author‚Äôs data self sufficient but less usable for other purpose than just showing them to end users)</li>
</ul>

<p>But even using one of those ‚Äúsolutions‚Äù, if no actual ISO3166 code is ever used, consumer programs will have hard time to actually interpret such specific way of representing countries.
Maybe they‚Äôll have to work on country names to match what they know of country on their side (probably ISO3166 based)‚Ä¶ hoping country names are actually returned in english and without typos.
It can be more a guess than an actual matching.
Maybe consumers developers will painfully build a mapping table based on the data they get‚Ä¶
But it will need to be updated if new countries are added.
I don‚Äôt mean actual new countries, that‚Äôs a possibility but that don‚Äôt happen much, but new authors from countries that were not already represented in the authors list.</p>

<p>On the other hand, using a standard ISO3166 code will makes both consumer and provider jobs easier because they naturally share common identifiers.
Ideally, when I see a <code>GET /authors</code> and as I know authors countries are returned, I can guess that <code>GET /authors?country=FRA</code> will return french authors.
It‚Äôs a no brainer, impossible to achieve with a custom country code.
If I use ISO3166 codes on my side, matching my data with the one coming from <code>GET /authors</code> based on countries is dead simple.
And I don‚Äôt care if new countries appear in authors data as I rely on the same ISO3166 referential: my consumer is always be up to date.</p>

<h2 id="well-known-identifiers">Well known identifiers</h2>

<p>But sometimes it‚Äôs not possible to use a ‚Äústandard‚Äù identifier known by everyone in the outside world.
It‚Äôs actually fairly common to use custom identifiers, but if that‚Äôs the case always favor the ‚Äúwell known‚Äù ones.
For instance, if you need a product identifier (for <code>GET /products/{productId}</code>), better use an id shared by a few APIs across a domain or an id shared across the whole organization than using an API specific product id.
A well known product id could be used across various APIs such as ‚Äúproduct catalog‚Äù, ‚Äúorder‚Äù, ‚Äúshipping‚Äù, ‚Äúsupplier‚Äù, ‚Äústorage‚Äù, ‚Ä¶
The more systems will share the same ids, the better.
It‚Äôs basically about using or defining local standards.
Doing so, any system knowing such well known ids can use them with any API inside a domain or the organization.</p>

<p>And note that it‚Äôs always good to double check if by chance there‚Äôs a standard identifier that you can use.
If the ‚Äúproduct‚Äù we were talking about reveals to be a ‚Äúbook‚Äù, prefer the use of an ISBN standard book identifier than your custom one, even if it is known across your organization (and change your resource name, <code>GET /books/{isbn}</code>).
Indeed, your well known ids are still custom ones and so unknown by the outside world.</p>

<p>Choosing interoperable data that other systems will interpret easily, data that is known by as much systems as possible, is a must do to create successful APIs.
But when creating APIs, you do not only deal with programs.
There are humans in the loop: the developers who write the programs using those APIs.</p>

<h1 id="human-readability">Human-readability</h1>

<p>Though choosing interoperable data actually makes API more human-friendly, because ‚Äúcommon language‚Äù and ‚Äúshared identifiers‚Äù, only focusing on machine to machine interoperability without taking care of human-readability could cripple your APIs success.</p>

<h2 id="obvious">Obvious</h2>

<p>The more obvious values are the better.
A <code>REQUIRED_TITLE</code> error code returned with a <code>400 BAD REQUEST</code> on a <code>POST /books</code> to add a book is easily understandable.
It‚Äôs understandable but quite specific; probably defined at a single API level.
Maybe using a more generic code defined for the whole organization in your guidelines, reusable in many contexts, could be better.
A generic <code>REQUIRED_PROPERTY</code> error code returned with a <code>"property": "title"</code> is more interoperable.</p>

<h2 id="guessable">Guessable</h2>

<p>A <code>FRA</code> alpha-3 ISO3166 code is better than it‚Äôs numeric counter part <code>250</code>, a human being can guess what it means.
It‚Äôs also quite simple to guess other alpha-3 ISO3166 code, for instance, what is the one for Italy?</p>

<p>But that does not mean numeric values are always evil.
Take HTTP status codes, such as <code>400</code> or <code>418</code> for instance.
They require some basic HTTP knowledge to understand what they mean; any <code>4XX</code> is an error caused by consumer.
But once you have that knowledge you can guess what means any HTTP status code.
Never heard about <code>418</code>, no problem, you can guess that‚Äôs consumer fault.
By the way, being guessable, or interpretable should I say, like this is also interesting for the consumer program, it actually makes data more interoperable.</p>

<h2 id="human-friendly">Human friendly</h2>

<p>Note that creating obvious or guessable values is not always possible, especially when there are countless of them.
Many times, you‚Äôll have to rely on opaque ids, but that does not mean they should be hard to remember or type for us, poor human beings.
An ISBN book identifier such as <code>9781617295102</code> is far more human friendly than a UUID <code>3ba5d648-8cce-433a-8013-aa760468c153</code> but less than a short id like <code>g2ma67</code>.
And I think that <code>123456</code> is more human friendly than all the others.</p>

<p>But don‚Äôt forget that interoperability always prevail over human-readability.
In that case, even though <code>123456</code> is more human-friendly, it‚Äôs still an internal id known only by the system which has created it, while <code>9781617295102</code> is a standard ISBN known widely outside of the organization.</p>

<h1 id="how-to-choose-identifiers">How to choose identifiers</h1>

<p>So how to choose identifiers, ids and codes?
First, try to find the most interoperable ones, and second, try to keep them as much human readable as possible.</p>

<div class="image ">
    <figure class="figure">
        <img src="/images/how-to-choose-ids-and-codes-to-build-userfriendly-and-interoperable-apis/scientific-quadrant-for-identifiers-how.jpg" class="figure-img img-fluid" /></figure>
</div>

<p>The level of interoperability of an API depends on the level of ‚Äústandardization‚Äù of its data.
A standard identifier will be easily understood by many systems while an internal one will be understood only by the system creating it.
But ‚Äústandardization‚Äù does not always mean ‚Äústandard‚Äù (like ISO country codes), sometimes using well known shared identifier inside an organization or a domain will be sufficient.</p>

<p>The developer experience will also be enhanced when using human readable identifiers; easy to understand, easy to type, easy to remember, easy to guess.</p>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[As an API designer, why should you care about the value of a productId, a countryCode, or an error code? Because wisely choosing the value of such (in a broad sense) ‚Äúidentifiers‚Äù greatly participates in the making of a user friendly API; but most importantly an interoperable one.]]></summary></entry><entry><title type="html">What should come first when designing an API?</title><link href="https://apihandyman.io/what-should-come-first-when-designing-an-api/" rel="alternate" type="text/html" title="What should come first when designing an API?" /><published>2021-12-22T00:00:00-06:00</published><updated>2021-12-22T00:00:00-06:00</updated><id>https://apihandyman.io/what-should-come-first-when-designing-an-api</id><content type="html" xml:base="https://apihandyman.io/what-should-come-first-when-designing-an-api/"><![CDATA[<p>Either you provide public or private APIs, you must have a design first approach.
But what does actually mean ‚Äúdesign first‚Äù?
Does it mean religiously writing all your <code>GET /this</code> and <code>POST /that</code> in an OpenAPI file?
But if that so, how is this so different from the code first approach where you write actual code to generate an OpenAPI file?
Maybe it‚Äôs time to clarify what should come first when designing API.
<!--more--></p>

<h1 id="definitions">Definitions</h1>

<p>The ‚Äúdesign first‚Äù and ‚Äúcode first‚Äù approach are very often opposed to each other.</p>

<p>The ‚Äúcode first‚Äù approach consists in coding the implementation and generating from it a formal description afterwards, usually an OpenAPI Specification file.
If you‚Äôve read this blog you know what I think about generating OpenAPI from code in such a case (if not, you should read <a href="/6-reasons-why-generating-openapi-from-code-when-designing-and-documenting-apis-sucks/">6 reasons why generating OpenAPI from code when designing and documenting APIs sucks</a>).
This approach has some serious drawbacks but I work with teams who are happy with it.
Either you like it or not, either it can have some drawbacks (but also some advantages), should this approach be opposed to ‚Äúdesign first‚Äù?</p>

<p>Nope, that‚Äôs a wrong debate.
The ‚Äúdesign first‚Äù approach is unfortunately more often than not used to describe something else.
Indeed, it is often used to describe the ‚Äúspec first‚Äù approach, an approach in which you describe formally an API using an API specification format such as the OpenAPI Specification before writing any line of code of the implementation.</p>

<p>So, what means ‚Äúdesign first‚Äù?
The ‚Äúdesign first‚Äù approach simply means you actually ‚Äúdesign‚Äù your API before doing anything else.
And that could actually be done in both ‚Äúspec first‚Äù and ‚Äúcode first‚Äù approaches.
Indeed, if I know my API needs a <code>GET /this</code>, and even if <a href="(/6-reasons-why-generating-openapi-from-code-when-designing-and-documenting-apis-sucks/)">generating OpenAPI Spec from code sucks</a>, there‚Äôs no big difference between writing OpenAPI Spec code and your favorite language code.</p>

<p>There‚Äôs no big difference ‚Ä¶ as long as you actually <em>design</em> your API first.</p>

<h1 id="natural-language-almost-first">Natural language almost first</h1>

<p>So what truly is this ‚Äúdesign first‚Äù approach that you MUST actually use to create APIs?
When designing an API, what should come first is not thinking about <code>GET /this</code> and <code>POST /that</code>.
What comes first is the needs your API should fulfill.
And those needs are not <code>GET /this</code> and <code>POST /that</code>, those needs are more like ‚ÄúSearch products‚Äù or ‚ÄúPlace an order.</p>

<p>Before thinking about HTTP methods and resource paths, you must have a clear understanding of the needs.
And you must describe them using crystal clear natural language.
You usually start with high level needs like ‚Äúbuying some products‚Äù and decompose them in flows, each step being an actual operation of your API, like ‚ÄúSearch products‚Äù, ‚ÄúAdd product to basket‚Äù and ‚ÄúPlace an order‚Äù (read more about all that in my book <a href="https://www.manning.com/books/the-design-of-web-apis">The Design of Web APIs</a>).
Working using natural language allows to include everyone in the conversation and to focus on the business perspective while keeping REST &amp; HTTP heated discussions for later.
Actually having a clear description of what the API should do in natural language facilitate those later discussions.</p>

<p>By the way, if <a href="/excuse-my-french-api-or-being-an-english-as-a-second-language-api-designer/#when-should-i-use-english-during-design-process">you‚Äôre an ESL API Designer I recommend to do that in your native language</a>.</p>

<p>So, whatever works in your context, spec or code first, design your API by working first on the needs using natural language.
That‚Äôs the heart of design first.</p>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[Either you provide public or private APIs, you must have a design first approach. But what does actually mean ‚Äúdesign first‚Äù? Does it mean religiously writing all your GET /this and POST /that in an OpenAPI file? But if that so, how is this so different from the code first approach where you write actual code to generate an OpenAPI file? Maybe it‚Äôs time to clarify what should come first when designing API.]]></summary></entry><entry><title type="html">Handle API gateway and backend differences in API documentation with OpenAPI Specification</title><link href="https://apihandyman.io/handle-api-gateway-and-backend-differences-in-api-documentation-with-openapi-specification/" rel="alternate" type="text/html" title="Handle API gateway and backend differences in API documentation with OpenAPI Specification" /><published>2021-12-15T00:00:00-06:00</published><updated>2021-12-15T00:00:00-06:00</updated><id>https://apihandyman.io/handle-api-gateway-and-backend-differences-in-api-documentation-with-openapi-specification</id><content type="html" xml:base="https://apihandyman.io/handle-api-gateway-and-backend-differences-in-api-documentation-with-openapi-specification/"><![CDATA[<p>I got yet another interesting question from my social networks: how to deal with the fact that an API contract can be different at gateway and implementation levels, and more precisely how to manage that when describing that contract with an OpenAPI file used as specification targeting API‚Äôs implementation‚Äôs developer and documentation targeting API‚Äôs consumers?
<!--more--></p>

<h1 id="the-question">The question</h1>

<p>The original question was this one: ‚ÄúI‚Äôm trying to work out how to use OpenAPI both as a service spec (with code generation) but also as documentation when the service will be deployed behind a gateway that will return some HTTP responses (401/403). Do I write in the OpenAPI spec what the end user sees (that an endpoint might return 401 say) even though the underlying service isn‚Äôt implementing that call? It makes the code generation ‚Äòwrong‚Äô but equally the developers need to know that the gateway configuration should protect it. Or do I make the OpenAPI reflect the service, in which case how do I tell the end users that they may see additional errors?‚Äù</p>

<p>So the question is how to deal with the fact that an API contract can be different at gateway and implementation levels, and more precisely how to manage that when describing that contract with an OpenAPI file used as specification targeting API‚Äôs implementation‚Äôs developer and documentation targeting API‚Äôs consumers</p>

<p>To answer that question, we need to talk about API gateways and how they can expose an API contract that is slightly different from the implementation‚Äôs one.</p>

<h1 id="how-contract-can-differ-between-gateway-and-implementation">How contract can differ between gateway and implementation</h1>

<div class="alert alert-info">
<p>Note that for this post <a href="/an-api-gateway-must-be-a-dumb-pipe/">we‚Äôll consider the gateway as as ‚Äúsmart-dump pipe‚Äù</a>, and so set aside the ‚Äúheavy transformation‚Äù use cases that are not relevant here.</p>

</div>

<p>An API gateway is a proxy that sits between backends providing APIs and their consumers.
Such proxy is useful to avoid reinventing the security wheel.
With an API gateway, dealing with the Oauth dance and ensuring that only registered consumers can use some API is just a piece of cake (though that does not mean it does ALL security job as shown in <a href="/an-api-gateway-alone-will-not-secure-your-api/">my previous ‚ÄúAn API Gateway alone will not secure your API‚Äù post</a>).
Other less known feature, gateways also provide throttling to ensure that a given consumer doesn‚Äôt do more than X call per second on a API or to ensure that a backend does not take more than Y call per second to protect non scalable infrastructure.</p>

<h2 id="errors-and-more">Errors and more</h2>

<p>Doing such stuff independently from the API implementation, an API gateway actually modifies exposed API contract.
Indeed, if a consumer makes an API call without an access token, they will get a <code>401 Unauthorized</code> response coming from the gateway, their API call having not reach the backend.
Same goes if a consumer goes beyond the X call per second, they may get a <code>429 Too Many Requests</code> coming from the gateway.
Those errors are not part of the original contract exposed by the backend.</p>

<div class="alert alert-warning">
<p>Important notice regarding errors: ensure that errors returned by your API gateway actually follow your API design guidelines.</p>

</div>

<p>But the API gateway may modify the contract beyond adding some errors.
As the gateway is a proxy, the server host is not the same at the gateway level (<code>https://cool-domain.com</code>) and the backend level (<code>https://obscure-server-name</code>).
It may change the base path, the backend exposing its API on <code>/api</code> and the gateway exposing on <code>/meaningful-name</code>.
A gateway may also add some HTTP headers in responses.</p>

<p>More tricky, the gateway may change security settings.
It‚Äôs fairly common to have various security modes available at the gateway level (Oauth, OpenID connect) but between the gateway and the backend a more generic, often JWT based security mode is used.</p>

<p>And even more tricky, you may have some endpoints at backend level that are only used internally and must not be exposed at gateway level.</p>

<h2 id="impacts-on-openapi-file">Impacts on OpenAPI file</h2>

<p>All that means the modifications can take place in the following places in an OpenAPI file:</p>

<div class="card card-code text-white bg-dark border-dark">
  
  <div class="card-header">
    <div class="row m-0">
      <div class="col align-self-center">
        <p class="m-0 title">Modified OpenAPI file</p>
      </div>
      <div class="col col-auto pr-0">
        <div class="btn-group" role="group" aria-label="code snippet control">
          <a role="button" class="btn btn-secondary code-copy-btn border-0 rounded-0" aria-label="copy" data-toggle="tooltip" data-placement="top" title="Copy"><img class="btn-icon" src="/images/commons/icons/copy.svg" /></a>
          <a role="button" class="btn btn-secondary border-0 rounded-0 code-expandcollapse-btn" aria-label="expand or shrink" onclick="expandCollapseCode(this)" data-toggle="tooltip" data-placement="top" title="Expand/Shrink"><img class="btn-icon" src="/images/commons/icons/maximize.svg" /></a>
        </div>
      </div>
    </div>
  </div>
  <div class="card-body">
    <pre class="language-yaml line-numbers code-collapsed code-copy"><code class="code-block">openapi: 3.0

servers:
    - url: # Gateway and backend won&#39;t have
           # same URLs (scheme, host, base path)

components:
    securityDefinitions:
        # Definitions of gateway specific security
        # modes different from backend

paths:
    /any-path: # Some paths may not be exposed on the gateway
        any-operation: # Some operations may not be exposed on the gateway
            security:
                # Usage of gateway specific security
                # modes different from backend
            responses:
                429: # Gateway will add or override HTTP
                     # status codes for all operations
                    headers:
                        # Gateway may add specific headers</code></pre>
  </div>
</div>

<h1 id="the-answer">The answer</h1>

<p>So how to deal with that regarding an OpenAPI file used as specification and documentation?</p>

<h2 id="consumers-perspective-first">Consumer‚Äôs perspective first</h2>

<p>First, what is 100% sure is that the consumers (well, their developers) must get access to a documentation describing the API from their perspective, that is the API gateway version.</p>

<p>If the difference between backend and gateway contract is only about getting a few errors like 401 or 429, you could possibly provide the backend reference documentation and have a dedicated pages to explain how some specific errors are handled.
But that means when consumers read the API reference documentation, these errors are not explicitly described.
And that is a problem in my humble opinion: as a developer using an API, I want to know exactly what happens reading the documentation of an operation.</p>

<p>That means, the reference documentation and hence the underlying OpenAPI file, must include those information. 
So how to achieve that?</p>

<h2 id="in-case-of-backend-specific-operations">In case of backend specific operations</h2>

<p>If your backend exposes specific operations that must not be exposed at gateway level, I would suggest to put them in a separate API.
Yes, a single backend can expose 2 different APIs on two different root path.
That will avoid the risk of unintentionally expose purely internal admin operations to the outside world.</p>

<h2 id="from-gateway-to-implementation">From gateway to implementation</h2>

<p>First option, create an OpenAPI file describing the API at the gateway level and tweak it, if needed, to use it at backend level:</p>

<ul>
  <li>Replace gateway <code>servers</code> by backend one(s)</li>
  <li>Replace gateway <code>securityDefinitions</code> by backend one</li>
  <li>Replace gateway operation <code>security</code> by backend one</li>
  <li>Remove or replace gateway specific <code>responses</code></li>
  <li>Remove gateway <code>specific</code> headers in <code>responses</code></li>
  <li>Add backend specific operations if you don‚Äôt want to separate them (see <a href="/#in-case-of-backend-specific-operations">In case of backend specific operations</a>)</li>
</ul>

<p>Don‚Äôt do that manually, do it programmatically to ensure exhaustivity and consistentcy.
You can use <a href="/toolbox/jq/">JQ</a> or an OpenAPI parser.</p>

<h2 id="from-implementation-to-gateway">From implementation to gateway</h2>

<p>The second way of dealing with that problem would be to transform the OpenAPI file describing the implementation‚Äôs contract into the gateway one.</p>

<p>In a code first approach, you could use the implementation‚Äôs documentation (OpenAPI) generator to do the transformation.
If you‚Äôre coding in Java, it‚Äôs dead simple to do all the modifications programmatically with SpringFox.</p>

<p>In both code first and spec first approaches, you can also do the transformations on an implementation version spec before or during deployment.
If you‚Äôre very lucky, your API gateway manages that transformation magically (but I doubt that actually exists).
If not, proceed like in ‚Äúgateway to implementation‚Äù scenario using <a href="/toolbox/jq/">JQ</a> or an OpenAPI parser to modify the file.</p>

<p>Whatever the way of doing the modifications, they would be:</p>

<ul>
  <li>Replace backend <code>servers</code> by gateway one</li>
  <li>Replace backend <code>securityDefinitions</code> by gateway one</li>
  <li>Replace backend operation <code>security</code>by gateway one</li>
  <li>Add gateway specific <code>responses</code></li>
  <li>Add gateway <code>specific</code> headers in <code>responses</code></li>
  <li>Remove backend specific operations if needed (see <a href="/#in-case-of-backend-specific-operations">In case of backend specific operations</a>)</li>
</ul>

<h2 id="gateway-and-implementation">Gateway and implementation</h2>

<p>And last but not least: doing both.
You can create an OpenAPI file describing the two versions and then strip it of unwanted elements before using it as gateway or backend level.
In my humble opinion that seems to be the best solution.
Indeed, you actually define explicitly what happens at both level and especially at gateway level (it‚Äôs up to provider to decide how to use scope for instance).
And when it comes to modify the OpenAPI file, it‚Äôs quite simple to remove elements.
A middle-ground even better option could be to use templates or script to handle the addition of gateway errors or headers (which are always the same).</p>

<p>Note that using a linter such as <a href="/toolbox/spectral/">Spectral</a> can ensure that your OpenAPI file(s) are actually valid ones (defining all errors for instance).</p>

<h1 id="consumer-first-and-machine-readability">Consumer first and machine readability</h1>

<p>Two important things to remember after reading this post:</p>

<ul>
  <li>The consumers MUST get a documentation, hence an OpenAPI file, that matches the API they see without bothering them with internal concerns (for instance that ‚Äúthe‚Äù API is actually build upon 2 components).</li>
  <li>And whenever you need to tweak the documentation/description of an API, better take advantage of a machine readable format such as the OpenAPI and do the modifications programmatically not manually</li>
</ul>]]></content><author><name>Arnaud Lauret</name></author><category term="post" /><summary type="html"><![CDATA[I got yet another interesting question from my social networks: how to deal with the fact that an API contract can be different at gateway and implementation levels, and more precisely how to manage that when describing that contract with an OpenAPI file used as specification targeting API‚Äôs implementation‚Äôs developer and documentation targeting API‚Äôs consumers?]]></summary></entry><entry><title type="html">Le Clash REST vs GraphQL</title><link href="https://apihandyman.io/le-clash-rest-vs-graphql/" rel="alternate" type="text/html" title="Le Clash REST vs GraphQL" /><published>2021-12-09T00:00:00-06:00</published><updated>2021-12-09T00:00:00-06:00</updated><id>https://apihandyman.io/le-clash-rest-vs-graphql</id><content type="html" xml:base="https://apihandyman.io/le-clash-rest-vs-graphql/"><![CDATA[<p>L‚Äôid√©e folle de l‚Äô√©quipe <a href="https://www.youtube.com/channel/UCIuBHEwIFRjwRMm9--Ga1vg">Microsoft User Group France</a> pour API Days Paris 2021: un clash REST (repr√©sent√© par votre serviteur) vs GraphQL (repr√©sent√© par <a href="https://twitter.com/CaptainJojo42">Jonathan Jalouzot</a>, tenancier du Meetup GraphQL Paris) arbitr√© par <a href="https://twitter.com/nbarrasson">Nicolas Barrasson</a>.
<!--more-->
J‚Äôavoue avoir √©t√© un peu dubitatif au d√©but car je ne suis pas fan de l‚Äôid√©e du clash, mais le concept est bien r√¥d√© et il ne s‚Äôagit pas de se friter b√™tement.
C‚Äôest un moyen sympa de d√©couvrir deux technos et de comparer les avantages et inconv√©nients avec une dose d‚Äôhumour.
Et puis je m‚Äôen suis pas trop mal sorti: meilleur troll, meilleur uppercut et meilleur clasheur.
Mais REST a-t-il vraiment gagn√© sur GraphQL?</p>

<h1 id="abstract">Abstract</h1>

<p>Les APIs web font tourner le monde. Nos SI ne seraient rien sans elles; pas de site web, pas d‚Äôapplications mobiles, pas de microservices, pas de cloud. Mais ce n‚Äôest pas qu‚Äôun sujet IT, le business ne serait rien sans elles non plus; pas de paiements instantan√©s avec Stripe, pas de colis Amazon d√©pos√© en 24h dans votre boite aux lettres, et au-del√†, toutes les entreprises, quel que soit leur domaine, doivent envisager de proposer des APIs.
Le probl√®me c‚Äôest qu‚Äôil n‚Äôy a pas un seul type d‚ÄôAPI Web, et ces derniers temps, il y en a 2 qu‚Äôon oppose tr√®s souvent: le v√©n√©rable REST et le challenger GraphQL.
Comment choisir objectivement l‚Äôun ou l‚Äôautre?
Sont-ils aussi forts, aussi parfaits que leurs aficionados respectifs le disent?
L‚Äôun des deux va-t-il √™tre sacr√© empereur √©ternel des APIs Web?
Vous saurez vous faire un avis gr√¢ce √† ce clash d‚Äôanthologie.</p>

<h1 id="video">Video</h1>

<div id="JjSUePBTLj4" class="third-party-content third-party-content-youtube">
    <div class="card third-party-content-warning">
        <img class="card-img" src="/images/thirdpartycontents/le-clash-rest-vs-graphql.jpg" alt="Card image" />
        <div class="card-img-overlay d-flex">
            <div class="my-auto mx-auto text-center">
                <p>This content is hosted on youtube.com.</p>
                <p>By showing this third party content you accept YouTube (Google)'s 
                    <a class="privacy-policy" href="https://policies.google.com/privacy" target="_blank">privacy policy</a>.
                </p>
                <form>
                    <a href="javascript:thirdPartyConsent('JjSUePBTLj4', 'youtube')" class="btn btn-primary" role="button">Show third party content</a>
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input third-party-content-remember" />
                        <label class="form-check-label" for="exampleCheck1">Remember my choice</label>
                        <p>(can be changed in <a class="privacy-policy" href="/privacy/">privacy settings</a>)</p>
                      </div>
                </form>
            </div>
        </div>
    </div>
    <div class="iframe-container third-party-content-iframe third-party-content-iframe-disabled">
        <iframe class="iframe-responsive" data-src="https://www.youtube-nocookie.com/embed/JjSUePBTLj4?color=white&amp;theme=light" frameborder="0" allowfullscreen="">
        </iframe>
    </div>
</div>]]></content><author><name>Nicolas Barrasson &amp; Jonathan Jalouzot &amp; Arnaud Lauret</name></author><category term="talk" /><summary type="html"><![CDATA[L‚Äôid√©e folle de l‚Äô√©quipe Microsoft User Group France pour API Days Paris 2021: un clash REST (repr√©sent√© par votre serviteur) vs GraphQL (repr√©sent√© par Jonathan Jalouzot, tenancier du Meetup GraphQL Paris) arbitr√© par Nicolas Barrasson.]]></summary></entry></feed>